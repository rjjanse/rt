---
title: "Accessing and manipulating data"
---

## Accessing data
Now that we have seen some basic R operations, such as functions and creating some data, let's see some ways to access this data and play with it. For this we'll mainly be working with dataframes and matrices. As an example, we will use the `iris` dataset, which is loaded into R by default. You can view the data just by running `iris` in your console:

```{r}
#| code-fold: false
iris
```

Although this is fine for small datasets, and seems okay for the `iris` datset, data will easily be too large to properly display in the console. In that case, we can choose to see only the beginning or the end of the data, using the `head()` and `tail()` functions. With these functions, you can specify the number of rows in a certain dataset that you want to see. For example, to see the first 4 and the last 5 rows of the iris dataset, we can do the following:

```{r}
#| code-fold: false
head(iris, n = 4)

tail(iris, n = 5)
```

:::{.callout-important appearance="simple"}
Note that because iris is loaded in by default, it does not appear in your global environment. To have it appear there, you can simply run:
```r
iris <- iris
```
:::

This is already much clearer. Nonetheless, we might want to see the whole data, for example to quickly look for inconsistencies. You can do this just by clicking on the name of the data in your global environment, or by using the `view()` function:

```r
view(iris)
```

When we use `view()` or open data from the global environment, RStudio offers as some quick tools to get a better overview of our data. After opening the data, you will see something similar to @fig-view, where you can see some areas of interest demarcated.

![Viewing data](images/view.png){#fig-view fig-alt="Viewing data" fig-align="center" height=60%}

We can now scroll through the data and see all columns. If you wonder how many rows and columns you have, you can see this at the bottom of the window. The viewer will only show 50 columns at a time, but you can click through the columns if you have more than 50. If you want to see only entries that meet a certain condition, you can press the filter button at the top of the viewer to filter certain values. Lastly, you can sort a column as ascending or descending by clicking on the little arrows to the right of the column name. Note that any operation you perform on the data in the viewer (sorting, filtering), does not affect the actual data, only the data you see. In other words, you only manipulate what you see in the data, not the data itself.

## Accessing the data
We now have a data frame with data inside, loaded in our environment. However, how can we actually access that data? For that, we can 'subset' the data. There is three ways we can do that:

### Dollar operator: $
The dollar operator, `$`, allows you to quickly subset a column from the data. This is a good way to have a quick look in your data. For example, if we want to subset the column `Sepal.Length`, we can simply do the following:
```{r}
#| code-fold: false
iris$Sepal.Length
```

As you can see, this returns a vector with the values. 

### Single brackets: []
Imagine we want a specific row, a specific column, or even a specific cell from our data. In that case, `$` is insufficient. Luckily, we can use single brackets: `[]`. When using single brackets on a data frame, we can put two things in-between the brackets: the row-number we are interested in and the column we are interested in. These can be both index numbers and row/column names. If we want to select all rows or all columns, we can leave that argument empty. Let's see some examples:
```{r}
#| code-fold: false
# Select the value in the 14th row and 4th column
iris[14, 4]

# Select the second column by name with all rows
iris[, "Sepal.Width"]

# Select the value in the 11th row and 4th column by index and name
iris[11, "Petal.Width"]

```

::: {.callout-note collapse="true"}
## Meow?
While writing this tutorial, my cat walked on my keyboard and decided she wanted to add the following:

ckxcccccccccccccccccccccccccccccccccccccc[[[[[[[['xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc.9Â¿']]]]]]]]

:::

Now we can go even further with our brackets. When we subset our data frame once, we get a vector of values. Imagine we want to subset the 4^th^ value of the column `Sepal.Width`, we can simply do:
```{r}
#| code-fold: false
iris[, "Sepal.Width"][4]
```

However, our fun doesn't stop here! What if we didn't want the 4^th^ value, but all values larger than 3.0? Easy; let's see how it works:

```{r}
#| code-fold: false
# We can get a vector of the column Sepal.Width as we saw before
iris[, "Sepal.Width"]

# From this vector, we can get per value a logical (TRUE or FALSE) whether it is >3.0
iris[, "Sepal.Width"] > 3

# We can use these logicals to subset the column to only keep values >3.0
iris[, "Sepal.Width"][iris["Sepal.Width"] > 3]

## To make it more readable, we could of course store the logicals in their own vector which we use to subset
# Create vector with logicals
larger_than_3 <- iris[, "Sepal.Width"] > 3

# Subset Sepal.Width
iris[, "Sepal.Width"][larger_than_3]

```

### Double brackets: [[]]
Instead of single brackets, we can also use double brackets. So what is the difference? First of all, we can supply only one argument to `[[]]`. In the case of a data frame, this means we cannot subset certain rows, but we can still subset columns. In a vector, we can use `[[]]` as seen before. So what is the difference between single brackets (`[]`) and double brackets (`[[]]`)?

In vectors and matrices, using double brackets instead of single brackets will drop any attributes and names attached to the data (such as column labels). To subset on a list, double brackets can be used for single values/elements while single brackets return a list of the elements. You may notice that the difference is not big, but it is still good to have heard about it once. More can be found [here](https://stackoverflow.com/questions/1169456/the-difference-between-bracket-and-double-bracket-for-accessing-the-el).

::: {.callout-important appearance="simple"}
Although the `$` operator is a quick way to access some data, it is recommended to not use it in the actual scripts you write. You can use `$` to check out some data in the console or have quickly check something, but in your script you should use `[]` or `[[]]`. This allows you to easily transform code into your own functions (which we will see later). Additionally, dollar operators do not allow logicals, while brackets do.
:::

## Logicals

## Which

## Get and assign

## Value types