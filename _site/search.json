[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "Hi and welcome to this R tutorial! This tutorial aims to teach you the basics of R (and RStudio) and some useful applications in using R for epidemiologic data analysis (which has many overlaps with data science), such as how to perform regression analyses and plot results.\nThroughout the tutorial, there will be example code. Feel free to also write and run this on your own device and play around with changing things up to see what happens.\nAdditionally, there will be exercises you can make to keep track of your learning progress. Answers to the exercises are available under the ‘Answer’ button. An example is shown below.\n\nExercises\n0: Open the answer\n\n\nAnswer\n# Well done!\n\n\nNext: R"
  },
  {
    "objectID": "r.html",
    "href": "r.html",
    "title": "R",
    "section": "",
    "text": "R is a programming language with a specific focus on statistical programming. A large part of the original R programming language took inspiration from the S programming language. This is also where it also got its name (R being next to S in the alphabet), together with R being the first name of the developers (Ross Ihaka and Robet Gentleman). R first appeared in August 1993 and the first official R version 1.0 was released on the 29th of February, 2000 (Source)."
  },
  {
    "objectID": "r.html#installing-r",
    "href": "r.html#installing-r",
    "title": "R",
    "section": "Installing R",
    "text": "Installing R\nLet’s start by installing R. R can be used on Windows, Apple, and Linux operating systems. To download R, you can go to https://cran.rstudio.com, where you can choose the download link applicable to your platform.\nAfter R is installed, you can open it and you will see the following screen:\n\n\n\nFigure 1: R graphical user interface\n\n\nIn Figure 1, you can see the R console, which allows you write code to subsequently yield results. However, as you might have noticed, the interface is quite limited in the information it shows you. This is why it is a good idea to install an Integrated Development Environment (also called an IDE).\nNext: Installing the RStudio IDE"
  },
  {
    "objectID": "rstudio.html",
    "href": "rstudio.html",
    "title": "RStudio",
    "section": "",
    "text": "One of the most popular IDEs for R is RStudio, developed by Posit. RStudio is an especially great IDE for R because it was developed specifically with R in mind. Although other IDEs exist, these are often more general, meaning there is functionality that is not relevant to R, or that there are implementations missing that could greatly benefit R users. Additionally, if you are ever interested in working with Python, RStudio also supports Python, as well as integration of Python and R into the same document.\nRStudio can be downloaded from https://posit.co/download/rstudio-desktop/. You have already downloaded R in the previous section so you can immediately go to step two and download RStudio desktop."
  },
  {
    "objectID": "rstudio.html#finding-your-way-around-rstudio",
    "href": "rstudio.html#finding-your-way-around-rstudio",
    "title": "RStudio",
    "section": "Finding your way around RStudio",
    "text": "Finding your way around RStudio\nNow let’s see what RStudio offers us compared to the graphical user interface of R itself. When we open RStudio, Figure 1 shows what we see:\n\n\n\nFigure 1: Default RStudio\n\n\n\nInterface\nFirst, let’s see what each section in the RStudio window, as numbered in Figure 2, means.\n\nThe first section is the script. In the script is where you will write most of your code. Scripts are text files that are saved on your device and you can load in later, meaning any code you write you can reuse later, without writing it again.\nThe second section is the console. Any code you run in the script will show its output in the console. Additionally, if you quickly want to see the output of some code, you can write it in the console instead of the script (but it won’t be saved then).\nThe third section is the global environment. Any data you create wil show up in here and from here you can inspect the data and details related to the data.\nThe fourth section contains multiple tabs, of which many are relevant to any R user.\n\nThe first tab is the ‘Files’ tab. When you are working on some code in R, it is possible to determine from where files are loaded and where files are saved by default. This location is automatically opened in the ‘Files’ tab, from where you can inspect the location and load any files by hand.\nThe second tab is the ‘Plots’ tab. Whenever you create a plot (i.e., figure) in R, it will show up in this tab, so that you can visually inspect whether you like it before exporting it.\nIn the third tab, ‘Packages’, you can find all Packages (more on those later) you have installed and see which ones are loaded. Additionally, you can update packages from this tab.\nThe ‘Help’ tab, the fourth of the tabs available, allows you to search for functions and packages and helps you understand how they work and how to enter data into them to obtain the desires results.\nThe last tab of interest for now, the ‘Viewer’ tab, allows you to view created documents. Sometimes, R allows you to documents, such as HTML documents (of which we will see an example later on), which can then be visually inspected in the viewer before export.\n\n\n\n\n\nFigure 2: RStudio interface\n\n\nThese are all the important sections and tabs any RStudio user should know about. Don’t worry if you don’t immediately understand or remember what the windows do or represent. Throughout the tutorial, they will come back and through practice you will get a good understanding of what you see in your RStudio window.\n\n\nSettings\nSecond, let’s highlight some good settings that can ease your programming in R. The settings I will highlight here are my personal preference and in no way something you must adhere to, but it is good to know that they exist and that get an idea of the extent to which you can personalize the way RStudio works for you.\nTo open the settings, you can go to ‘Tools’ in the menu bar at the top of the screen, and select ‘Global options’ in the drop-down menu, shown in Figure 3.\n\n\n\nFigure 3: Going to global options\n\n\n\nSaving the workspace\nA first setting I want to highlight is saving the workspace. By default, when you exit RStudio, RStudio will ask you whether you want to save the workspace. The saved workspace will then be restored upon re-opening R. In other words, any data you created and loaded in would be saved upon quitting RStudio and loaded back in when you start RStudio again. Although this may sound useful, it also means that all data you create needs to be removed manually. This can quickly cause problems with memory and the speed of R and your device. Therefore I suggest that under ‘General’ you remove the tick from ‘Restore .RData into workspace at startup’ and set Save workspace to .RData on exit to Never as seen in Figure 4.\n\n\n\nFigure 4: Workspace settings\n\n\n\n\nCode display\nTo make our code a bit more readable, I suggest changing a few settings under the section ‘Code’ in the tab ‘Display’ as seen in Figure 5. I prefer changing the following settings regarding my code display:\n\nMargin: by default, the scripts in R show a margin (a vertical line) on the right of a code. This can help you style your code width if you use RStudio on different devices with different screen widths. Personally, I like to turn the margin off by removing the tick from ‘Show margin’.\nScrolling past end: when you write a code in a script, you can scroll to the end of the script, but not further, However, personally I prefer to have the code that I am looking at be in the middle of the screen. By ticking ‘Allow scroll past end of document’, I can keep scrolling after the code finishes to center the code in the window.\nHighlight functions: in R, we can calculate many things using functions (more on this later). However, these normally are the same colour as the rest of your code. I prefer to highlight functions to increase readability. You can do this by ticking ‘Highlight R function calls’.\nRainbow parentheses: many of the code that is written in R uses parentheses: (). However, many parentheses within each other might become very confusing: (((()))). Although R highlights the corresponding parenthesis, I find it helpful to additionally colour corresponding parentheses the same colour, while non-corresponding parentheses are coloured different. You can do this by ticking ‘Rainbow parentheses’.\n\n\n\n\nFigure 5: Code display settings\n\n\n\n\nRStudio appearance\nWhen working in RStudio, I prefer the screen to not be too bright. Additionally, I modified the way the code looks to my own preferences. You can try what works best for you under ‘Appearance’ (Figure 6).\n\n\n\nFigure 6: RStudio appearance settings\n\n\nNext: R Basics"
  },
  {
    "objectID": "basics.html",
    "href": "basics.html",
    "title": "Creating and storing data",
    "section": "",
    "text": "Let’s get started in R. Before we write any code, we should discuss the importance of annotation. When you are writing code it might seem clear to you what each line does, but if someone else reads your code or you look back at your code after a while, it might not seem so clear anymore. To allow others and your future-self to efficiently check, read, and re-use your code, it is important to extensively annotate your code. Let’s see some unannotated code (you don’t have to understand now what the code means):\niris %>%\n    filter(Species == \"setosa\") %>%\n    extract2(\"Sepal.Length\") %>%\n    is_greater_than(5) %>%\n    table() %>%\n    prop.table() %>%\n    extract2(TRUE) %>%\n    `*`(100) %>%\n    paste0(., \"%\")\nIn this section of code, there is a lot that happens (although some R users might still get the gist of the code). Moreover, a single section of code might quickly get much longer and more complicated than the above example. Luckily, the code can added to with annotation. In R, you can annotate with ‘#’. Any text written after the ‘#’ on the same line will not be run by R and can therefore be used to annotate code. So let’s see how we can increase this code’s clarity with annotation:\n# Calculate proportion of setosa observations with sepal length above 5\niris %>%\n    # Keep only setosa species\n    filter(Species == \"setosa\") %>%\n    # Keep only the sepal length values\n    extract2(\"Sepal.Length\") %>%\n    # Determine whether each value is greater than 5 or not\n    is_greater_than(5) %>%\n    # Count lengths above and below 5\n    table() %>%\n    # Turn counts into proportions\n    prop.table() %>%\n    # Keep only proportion for lengths above 5\n    extract2(TRUE) %>%\n    # Multiply by 100\n    `*`(100) %>%\n    # Add percentage sign\n    paste0(., \"%\")\nIt is true that annotation increases the length of a script, but it is important to note that the quality of a script is not affected by its length, but it is by its clarity.\n\n\n\n\n\n\nYou can use annotation for more than just explaining what your code does. You can add information on the general purpose of a script, its author, its creation date. You can add information on why you made a certain decision or add a URL to where you found the solution to a coding problem. It is easy to annotate too little, but difficult to annotate too much."
  },
  {
    "objectID": "basics.html#basic-mathematic-operators",
    "href": "basics.html#basic-mathematic-operators",
    "title": "R Basics",
    "section": "Basic mathematic operators",
    "text": "Basic mathematic operators\nNow let’s (finally) see some real code! Let’s start with some basic operators:\n1 + 1   # Addition\n3 - 1   # Substraction\n2 * 3   # Multiplication\n8 / 2   # Division\n8 %% 2  # Modulo"
  },
  {
    "objectID": "basics.html#basic-mathematic-operators-and-running-code",
    "href": "basics.html#basic-mathematic-operators-and-running-code",
    "title": "Creating and storing data",
    "section": "Basic mathematic operators and running code",
    "text": "Basic mathematic operators and running code\nNow let’s (finally) see some real code! Let’s start with some basic operators:\n1 + 1   # Addition\n3 - 1   # Substraction\n2 * 3   # Multiplication\n8 / 2   # Division\n8 %% 2  # Modulo\nR follows the conventional order of mathematic operation.\nHowever, these operators are useless if we do not actually run the code. To run a section of code, put your cursor in the code section (can be anywhere) and press ctrl + enter to run the code. If you want to run a specific part of the code, instead of a whole section, you can select the part you want to run and then use ctrl + enter again, to run only the selected part.\nThe results of the selected code can be found in the console. If the code takes some time to run, you can see it is done when a new line of the console starts with > (Figure 1 (a)).\n\n\n\n\n\n\nIf you select a specific part of code to run, make sure to be inclusive! For instance, if you forget to select an enclosing paranthesis, the selected code will be put in the console, but it will not be run. You can see that this happened if a new line in the console starts with + (Figure 1 (b)). To cancel a waiting command, you can press esc.\n\n\n\nIf we run the example code for the basic mathematic operators, we will get the following results:\n\n1 + 1   # Addition\n\n[1] 2\n\n3 - 1   # Substraction\n\n[1] 2\n\n2 * 3   # Multiplication\n\n[1] 6\n\n8 / 2   # Division\n\n[1] 4\n\n8 %% 2  # Modulo\n\n[1] 0\n\n\nBefore each result, you can see [1]. This indicates that that specific line of code starts with the nth result. When a single code starts printing multiple results, this can help identify what n a certain result is.\n\n\n\n\n\n\n\n(a) Ready\n\n\n\n\n\n\n\n(b) Waiting for input to finish\n\n\n\n\nFigure 1: Console states"
  },
  {
    "objectID": "basics.html#functions",
    "href": "basics.html#functions",
    "title": "Creating and storing data",
    "section": "Functions",
    "text": "Functions\nNow that we know the basic mathematic operators, we could calculate the standard deviation. For example, for the numbers 3, 8, 3, 7 and 1, we could do the following:\n\n# Calculate the mean\n(3 + 8 + 3 + 7 + 1) / 5\n\n[1] 4.4\n\n\n\n# Use the calculated mean to calculate the standard deviation\n(((3 - 4.4) ^ 2 + (8 - 4.4) ^ 2 + (3 - 4.4) ^ 2 + (7 - 4.4) ^ 2 + (1 - 4.4) ^ 2) / (5 - 1)) ^ 0.5\n\n[1] 2.966479\n\n\n\n\nA sample’s standard deviation \\(s\\) is obtained by calculating:\n\\[\\sqrt\\frac{\\sum{(x-\\overline{x})^2}}{n-1}\\]\nHowever, with only 5 numbers, this is already a lot of effort. This is where functions come in: R has many built-in keywords that allow you to quickly perform operations and/or calculations on the data, which we call functions. A function has a generic name and is followed by opening and closing brackets. Between the brackets, we can supply so-called arguments (i.e., data and/or specifications). For example, if we wanted to calculate the standard deviation, instead of typing out all the numbers, we could just type the following:\n\n# Calculate standard deviation\nsd(c(3, 8, 3, 7, 1))\n\n[1] 2.966479\n\n\n\n\n\n\n\n\nIn the standard deviation function, we use the c() function. Later we will elaborate on this, but for now it is enough to remember that c() creates a collection of data, which is more often called an object.\n\n\n\nLet’s see some standard functions that will be of great help to you.\n\nSum\nsum(), as it name suggests, sums the supplied values. It has the following arguments:\n\n...: the ellipsis indicates that any number of values can be supplied here. The sum function can take numeric values, integers, and booleans/logicals (i.e., it can sum the amount of TRUEs).\nna.rm = FALSE: na.rm indicates whether any missing values should be dropped. By default, this is FALSE, meaning that the function will return NA if there is any NAs present in the data you are trying to sum. If you want to sum all valid values (thus drop all NAs), you can specify na.rm = TRUE.\n\nSee the below examples:\n\nsum(3, 4, 5, 6)\n\n[1] 18\n\nsum(3, NA, 5, 6)\n\n[1] NA\n\nsum(3, NA, 5, 6, na.rm = TRUE)\n\n[1] 14\n\n\n\n\n\n\n\n\nIn the sum() function, na.rm has the default value FALSE. This means that this argument does not have to be defined. If we would not define it, it would just use FALSE.\n\n\n\n\n\nMean and median\nTo get the mean or median from some data, you can use the mean() and median() functions. mean() has the following arguments:\n\nx: a collection (or object) of data containing the data for which a mean should be calculated.\ntrim = 0: what proportion of the outskirts of the data should be trimmed (e.g., 0.05 trims 5% of data on each side). It defaults to 0.\nna.rm = FALSE: whether NAs should be dropped (as in sum())\n\nmedian() has the same arguments, except that it doesn’t have trim.\nHere are some examples:\n\nmean(c(3, 4, 8, 3, 0, 4, 7, 8, 3, 1, 1044))\n\n[1] 98.63636\n\nmean(c(3, 4, 8, 3, 0, 4, 7, 8, 3, 1, 1044), trim = 0.1)\n\n[1] 4.555556\n\nmedian(c(3, 4, 8, 3, 0, 4, 7, 8, 3, 1, 1044))\n\n[1] 4\n\n\n\n\n\n\n\n\nNotice how with the mean, we specified that 0.1 was the value for trim, but we did not specify that c(3, 4, 8, 3, 0, 4, 7, 8, 3, 1, 1044) was the value for x. This is because R inputs values for arguments in order: the first supplied value will be used for the first argument, the second supplied value will be used for the second argument, etc. However, sometimes I do not want to specify the second value, but I do want to specify the third value. In this case I can name the argument as in trim = 0.1, so that R knows the 0.1 is meant for trim.\n\n\n\n\n\nMin and max\nNow that we know how to calculate the mean and median from some data, we might also be interest in finding the lowest and highest value (for example, to detect the 1044 outlier). We can do this with min() and max(), which both take only one argument: ... as in the sum() function.\nTo get the minimum and maximum value from the data we just calculated the mean and median of, we could do the following:\n\nmin(3, 4, 8, 3, 0, 4, 7, 8, 3, 1, 1044)\n\n[1] 0\n\nmax(3, 4, 8, 3, 0, 4, 7, 8, 3, 1, 1044)\n\n[1] 1044\n\n\n\n\nSummary and quintile\nNow we know how to calculate the mean, median, minimum, and maximum values from some data, but what if we also want to know the 1st and 3rd quartile? Additionally, we do not want to use a function for each separate value. In this case, you can use summary(), which calculates the minimum, 1st quartile, mean, median, 3rd quartile, and maximum all at once. The summary function has multiple arguments, but only one is relevant for now:\n\nobject: the data of which you want to get a summary.\n\nFor example:\n\nsummary(c(3, 4, 8, 3, 0, 4, 7, 8, 3, 1, 1044))\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.00    3.00    4.00   98.64    7.50 1044.00 \n\n\nHowever, maybe we are more interested in the 1st and 99th quantiles. In that case we could use quantile(). You can supply the following arguments to quantile():\n\nx: a collection of data (or object) of which you want to calculate quantiles.\nprobs = seq(0, 1, 0.25): the probabilities (or quantiles) you want to calculate. It defaults to seq(0, 1, 0.25), which just means a sequence from 0 to 1 with increments of 0.25.\nna.rm = FALSE: whether NAs should be dropped.\nnames = TRUE: whether the output should show the name (or specified quantile).\n\nSo we could do:\n\nquantile(c(3, 4, 8, 3, 0, 4, 7, 8, 3, 1, 1044), \n         probs = c(0.01, 0.99))\n\n   1%   99% \n  0.1 940.4 \n\nquantile(c(3, 4, 8, 3, 0, 4, 7, 8, 3, 1, 1044), \n         probs = c(0.01, 0.99), names = FALSE)\n\n[1]   0.1 940.4\n\n\n\n\nTable\nWe have now seen some functions that we can use to get some descriptives about continuous data. However, sometimes we just want to count the amount of different observations. For this we can use table(). Some of the relevant arguments for the table function are the following:\n\n...: the variables to be supplied to table, as we saw in earlier functions.\nuseNA = c(\"no\", \"ifany\", \"always\"): should NAs be tabulated (conditional on if any are present) or not. The c(\"no\", \"ifany\", \"always\"), means that useNA takes any of the three following values: \"no\", \"ifany\", or \"always\".\n\nFor example:\n\ntable(c(TRUE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE, FALSE, NA))\n\n\nFALSE  TRUE \n    3     5 \n\ntable(c(TRUE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE, FALSE, NA), \n      useNA = \"ifany\")\n\n\nFALSE  TRUE  <NA> \n    3     5     1 \n\ntable(c(TRUE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE, FALSE), \n      useNA = \"always\")\n\n\nFALSE  TRUE  <NA> \n    3     5     0 \n\n\nYou can also use table() to create a cross-table:\n\ntable(c(FALSE, TRUE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE, FALSE), \n      c(TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE))\n\n       \n        FALSE TRUE\n  FALSE     3    1\n  TRUE      3    2\n\n\nFor the cross-tabulation, values are compered based on their order in the data you supply (e.g., the first value, FALSE in the first set is compared to the first value, TRUE, in the second set.)\n\n\n\n\n\n\nWe now went through some arguments for commonly used functions together, but it is good that you know what arguments a function takes and where you can find this. If you want to know more about any function, for example for sum(), you can open the documentation by running ?sum. In the help panel on the lower right in RStudio, you will find the documentation with the function, its default values, elaboration on the arguments it takes, details, and examples. You can also click on a function and press F1 to open the help panel."
  },
  {
    "objectID": "basics.html#storing-values",
    "href": "basics.html#storing-values",
    "title": "Creating and storing data",
    "section": "Storing values",
    "text": "Storing values\nWe have now seen how we can calculate some values using basic mathematic operators and functions. However, just typing out our data can become quite tiresome, so preferably I would store them in a variable. In R, things that store data are often called subjects. Let’s look at some different ways we can store data.\n\nSingle value\nWe can assign a single value by using the <- operator (which has the easy keyboard shortcut alt + - in RStudio). To then see the object, we can simply run it. For example:\n\nx <- sum(4, 9)\nx\n\n[1] 13\n\nx <- 4 + 5\nx\n\n[1] 9\n\n\n\n\n\n\n\n\nNote that we defined the object x twice. When defining an object that already exists, the old object is overridden.\n\n\n\n\n\n\n\n\n\nTo assign a value to an object, you can also use = instead of <-. However, this is often unclear and may be confused with defining arguments in functions. It is therefore strongly recommended to only assign objects using <-.\n\n\n\n\n\nVectors\nWhen we want to assign multiple values to a single variable, we can create a vector. There are two simple ways to create a vector. First, we can use the c function (c()), that we saw before when discussing functions. c() creates a simple collection of any type of value. We call this collection a vector.\n\nx <- c(4, 6, 9, 3, 2)\nx\n\n[1] 4 6 9 3 2\n\n# Using a vector in the sum function\nsum(x)\n\n[1] 24\n\n\nYou can also create a vector of sequential integers by using ::\n\nx <- 5:17\nx\n\n [1]  5  6  7  8  9 10 11 12 13 14 15 16 17\n\n\nAdditionally, you can create any sequence using the seq() function which takes the arguments from, to, and by, meaning respectively the start, finish, and increments of the sequence.\n\nx <- seq(5, 7, 0.5)\nx\n\n[1] 5.0 5.5 6.0 6.5 7.0\n\n\nWe could also multiply two vectors with each other (given they have the same length) or a vector with a single value:\n\nx <- 1:5\ny <- 5:1\n\nx * y\n\n[1] 5 8 9 8 5\n\nx * 2\n\n[1]  2  4  6  8 10\n\n\nLastly, you could create a named vector (i.e., each value has a name):\n\nx <- c(\"Obs1\" = 42, \"Obs2\" = 28, \"Obs3\" = 91)\nx\n\nObs1 Obs2 Obs3 \n  42   28   91 \n\n\n\n\nLists\nA list is also a collection of data, but it can store much more than just values, such as vectors, and whole data sets:\n\nx <- list(head(iris, 3), head(mtcars, 3))\nx\n\n[[1]]\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n\n[[2]]\n               mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4     21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710    22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\n\n\nHowever, you cannot immediately apply mathematic operators on a list or use a list in data. If we have a list with data (for example different objects), we first have to unlist:\n\nx <- list(4, 2)\nunlist(x) * 2\n\n[1] 8 4\n\n\nWhen you create a model, they are always stored in lists too, with many information alongside the results. We will come across this later in the tutorial.\n\n\nMatrices\nIf we want data with more than one dimension (i.e., columns and rows), we could create a matrix with the matrix function:\n\nx <- matrix(c(31, 3, 18, 7, 84, 20), nrow = 3, ncol = 2)\nx\n\n     [,1] [,2]\n[1,]   31    7\n[2,]    3   84\n[3,]   18   20\n\n\nWe can also supply a single value that fills the entire matrix:\n\nx <- matrix(\"Hello, World!\", nrow = 5, ncol = 3)\nx\n\n     [,1]            [,2]            [,3]           \n[1,] \"Hello, World!\" \"Hello, World!\" \"Hello, World!\"\n[2,] \"Hello, World!\" \"Hello, World!\" \"Hello, World!\"\n[3,] \"Hello, World!\" \"Hello, World!\" \"Hello, World!\"\n[4,] \"Hello, World!\" \"Hello, World!\" \"Hello, World!\"\n[5,] \"Hello, World!\" \"Hello, World!\" \"Hello, World!\"\n\n\nMatrices are useful because they have multiple dimensions, which allows us to store different variables of the same person in multiple columns along the same row.\n\n\nData frames\nMatrices give us a flexible way to store data with rows and columns, but miss some flexibility when it comes to manipulating the data and performing calculations, loading it into functions, etc. In this case, data frames offer a good solution. Data frames look exactly matrices, but are much easier to manipulate and use for analyses. Data frames are likely what will compose most of the data you use in R.\nWe can create a data frame with the data.frame() function:\n\nx <- data.frame(id = 1:5,\n                value1 = c(5, 2, 0, 2, 4),\n                value2 = c(9.4, 8.3, 2.8, 5.6, 2.7))\nx\n\n  id value1 value2\n1  1      5    9.4\n2  2      2    8.3\n3  3      0    2.8\n4  4      2    5.6\n5  5      4    2.7\n\n\nWhen working with data frames, there are some useful functions you can use:\n\nTo determine how many rows and columns a data frame (or matrix) has, you can use nrow() and ncol().\nTo change the row and column names, you can use rownames() and colnames(). To see how these functions work, you can access the examples in their documentation with ?rownames and ?colnames.\nTo change a data frame to a matrix or a matrix to a data frame, you can use as.matrix() and as.data.frame()."
  },
  {
    "objectID": "basics.html#the-global-environment",
    "href": "basics.html#the-global-environment",
    "title": "Creating and storing data",
    "section": "The global environment",
    "text": "The global environment"
  }
]