---
title: "Basics"
---

## Annotation
Let's get started in R. Before we write any code, we should discuss the importance of annotation. When you are writing code it might seem clear to you what each line does, but if someone else reads your code or you look back at your code after a while, it might not seem so clear anymore. To allow others and your future-self to efficiently check, read, and re-use your code, it is important to **extensively** annotate your code. Let's see some unannotated code (you don't have to understand now what the code means):

```r
iris %>%
    filter(Species == "setosa") %>%
    extract2("Sepal.Length") %>%
    is_greater_than(5) %>%
    table() %>%
    prop.table() %>%
    extract2(TRUE) %>%
    `*`(100) %>%
    paste0(., "%")
```

In this section of code, there is a lot that happens (although some R users might still get the gist of the code). Moreover, a single section of code might quickly get much longer and more complicated than the above example. Luckily, the code can added to with annotation. In R, you can annotate with '#'. Any text written after the '#' on the same line will not be run by R and can therefore be used to annotate code. So let's see how we can increase this code's clarity with annotation:

```r
# Calculate proportion of setosa observations with sepal length above 5
iris %>%
    # Keep only setosa species
    filter(Species == "setosa") %>%
    # Keep only the sepal length values
    extract2("Sepal.Length") %>%
    # Determine whether each value is greater than 5 or not
    is_greater_than(5) %>%
    # Count lengths above and below 5
    table() %>%
    # Turn counts into proportions
    prop.table() %>%
    # Keep only proportion for lengths above 5
    extract2(TRUE) %>%
    # Multiply by 100
    `*`(100) %>%
    # Add percentage sign
    paste0(., "%")
```

It is true that annotation increases the length of a script, but it is important to note that the quality of a script is not affected by its length, but it is by its clarity.

::: {.callout-tip appearance="simple"}
You can use annotation for more than just explaining what your code does. You can add information on the general purpose of a script, its author, its creation date. You can add information on why you made a certain decision or add a URL to where you found the solution to a coding problem. It is easy to annotate too little, but difficult to annotate too much.
:::

## Basic mathematic operators and running code
Now let's (finally) see some real code! Let's start with some basic operators:

```r
1 + 1   # Addition
3 - 1   # Substraction
2 * 3   # Multiplication
8 / 2   # Division
8 %% 2  # Modulo
```

R follows the [conventional order of mathematic operation](https://en.wikipedia.org/wiki/Order_of_operations#Programming_languages).

However, these operators are useless if we do not actually run the code. To run a section of code, put your cursor in the code section (can be anywhere) and press ctrl + enter to run the code. If you want to run a specific part of the code, instead of a whole section, you can select the part you want to run and then use ctrl + enter again, to run only the selected part. 

The results of the selected code can be found in the console. If the code takes some time to run, you can see it is done when a new line of the console starts with > (@fig-ready).

::: {.callout-important appearance="simple"}
If you select a specific part of code to run, make sure to be inclusive! For instance, if you forget to select an enclosing paranthesis, the selected code will be put in the console, but it will not be run. You can see that this happened if a new line in the console starts with + (@fig-waiting). To cancel a waiting command, you can press esc.
:::

If we run the example code for the basic mathematic operators, we will get the following results:
```{r}
#| code-fold: false
1 + 1   # Addition
3 - 1   # Substraction
2 * 3   # Multiplication
8 / 2   # Division
8 %% 2  # Modulo
```

Before each result, you can see `[1]`. This indicates that that specific line of code starts with the n^th^ result. When a single code starts printing multiple results, this can help identify what n a certain result is.

::: {#fig-console layout-ncol=2}
![Ready](images/console_ready.png){#fig-ready fig-alt="ready console" width=45%}

![Waiting for input to finish](images/console_waiting.png){#fig-waiting fig-alt="waiting console" width=45%}

Console states
:::

## Functions
Now that we know the basic mathematic operators, we could calculate the standard deviation. For example, for the numbers 3, 8, 3, 7 and 1, we could do the following:

```{r}
#| code-fold: false
# Calculate the mean
(3 + 8 + 3 + 7 + 1) / 5
```

```{r}
#| code-fold: false
# Use the calculated mean to calculate the standard deviation
(((3 - 4.4) ^ 2 + (8 - 4.4) ^ 2 + (3 - 4.4) ^ 2 + (7 - 4.4) ^ 2 + (1 - 4.4) ^ 2) / (5 - 1)) ^ 0.5

```

::: {.column-margin}
A sample's standard deviation $s$ is obtained by calculating:

$$\sqrt\frac{\sum{(x-\overline{x})^2}}{n-1}$$
:::

However, with only 5 numbers, this is already a lot of effort. This is where functions come in: R has many built-in keywords that allow you to quickly perform operations and/or calculations on the data, which we call functions. A function has a generic name and is followed by opening and closing brackets. Between the brackets, we can supply so-called arguments (i.e., data and/or specifications). For example, if we wanted to calculate the standard deviation, instead of typing out all the numbers, we could just type the following:

```{r}
#| code-fold: false
# Calculate standard deviation
sd(c(3, 8, 3, 7, 1))
```

:::{.callout-note appearance="simple"}
In the standard deviation function, we use the `c()` function. Later we will elaborate on this, but for now it is enough to remember that `c()` creates a **c**ollection of data, which is more often called an object.
::: 

Let's see some standard functions that will be of great help to you.

### Sum
`sum()`, as it name suggests, sums the supplied values. It has the following arguments:

- `...`: the ellipsis indicates that any number of values can be supplied here. The sum function can take numeric values, integers, and booleans/logicals (i.e., it can sum the amount of `TRUE`s).

- `na.rm = FALSE`: na.rm indicates whether any missing values should be dropped. By default, this is `FALSE`, meaning that the function will return `NA` if there is any `NA`s present in the data you are trying to sum. If you want to sum all valid values (thus drop all `NA`s), you can specify `na.rm = TRUE`.

See the below examples:
```{r}
#| code-fold: false
sum(3, 4, 5, 6)
sum(3, NA, 5, 6)
sum(3, NA, 5, 6, na.rm = TRUE)
```

:::{.callout-note appearance="simple"}
In the `sum()` function, `na.rm` has the default value `FALSE`. This means that this argument does not have to be defined. If we would not define it, it would just use `FALSE`.
:::

### Mean and median
To get the mean or median from some data, you can use the `mean()` and `median()` functions. `mean()` has the following arguments:

- `x`: a collection (or object) of data containing the data for which a mean should be calculated.

- `trim = 0`: what proportion of the outskirts of the data should be trimmed (e.g., 0.05 trims 5% of data on each side). It defaults to 0.

- `na.rm = FALSE`: whether `NA`s should be dropped (as in `sum()`)

`median()` has the same arguments, except that it doesn't have `trim`.

Here are some examples:
```{r}
#| code-fold: false
mean(c(3, 4, 8, 3, 0, 4, 7, 8, 3, 1, 1044))
mean(c(3, 4, 8, 3, 0, 4, 7, 8, 3, 1, 1044), trim = 0.1)
median(c(3, 4, 8, 3, 0, 4, 7, 8, 3, 1, 1044))
```

:::{.callout-important appearance="simple"}
Notice how with the mean, we specified that 0.1 was the value for `trim`, but we did not specify that `c(3, 4, 8, 3, 0, 4, 7, 8, 3, 1, 1044)` was the value for `x`. This is because R inputs values for arguments in order: the first supplied value will be used for the first argument, the second supplied value will be used for the second argument, etc. However, sometimes I do not want to specify the second value, but I do want to specify the third value. In this case I can name the argument as in `trim = 0.1`, so that R knows the 0.1 is meant for `trim`.
:::

### Min and max
Now that we know how to calculate the mean and median from some data, we might also be interest in finding the lowest and highest value (for example, to detect the 1044 outlier). We can do this with `min()` and `max()`, which both take only one argument: `...` as in the `sum()` function. 

To get the minimum and maximum value from the data we just calculated the mean and median of, we could do the following:
```{r}
#| code-fold: false
min(3, 4, 8, 3, 0, 4, 7, 8, 3, 1, 1044)
max(3, 4, 8, 3, 0, 4, 7, 8, 3, 1, 1044)
```

### Summary and quintile
Now we know how to calculate the mean, median, minimum, and maximum values from some data, but what if we also want to know the 1^st^ and 3^rd^ quartile? Additionally, we do not want to use a function for each separate value. In this case, you can use `summary()`, which calculates the minimum, 1^st^ quartile, mean, median, 3^rd^ quartile, and maximum all at once. The summary function has multiple arguments, but only one is relevant for now:

- `object`: the data of which you want to get a summary.

For example:
```{r}
#| code-fold: false
summary(c(3, 4, 8, 3, 0, 4, 7, 8, 3, 1, 1044))
```

However, maybe we are more interested in the 1^st^ and 99^th^ quantiles. In that case we could use `quantile()`. You can supply the following arguments to `quantile()`:

- `x`: a collection of data (or object) of which you want to calculate quantiles.

- `probs = seq(0, 1, 0.25)`: the probabilities (or quantiles) you want to calculate. It defaults to `seq(0, 1, 0.25)`, which just means a sequence from 0 to 1 with increments of 0.25.

- `na.rm = FALSE`: whether `NA`s should be dropped.

- `names = TRUE`: whether the output should show the name (or specified quantile).

So we could do:
```{r}
#| code-fold: false
quantile(c(3, 4, 8, 3, 0, 4, 7, 8, 3, 1, 1044), probs = c(0.01, 0.99))
quantile(c(3, 4, 8, 3, 0, 4, 7, 8, 3, 1, 1044), probs = c(0.01, 0.99), names = FALSE)
```


<!-- To do:
•	Functions
•	Basic functions
o	Sum, mean, median, summary, quintiles, min, max, table
•	Storing values in objects
o	Single value
	What operator to use: <- or =
o	Vector (& what is a vector)
o	List
o	Matrices
	Transforming to matrices
o	Dataframes
	Dimensions: nrow, ncol
	Setting column names
	Transforming to data frames
	Transforming matrices to data frames
•	Finding source code of a function
•	Methods() of functions
•	Global environment
o	Get & assign
Errors -->

