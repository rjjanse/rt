---
title: "Basics"
---

## Annotation
Let's get started in R. Before we write any code, we should discuss the importance of annotation. When you are writing code it might seem clear to you what each line does, but if someone else reads your code or you look back at your code after a while, it might not seem so clear anymore. To allow others and your future-self to efficiently check, read, and re-use your code, it is important to **extensively** annotate your code. Let's see some unannotated code (you don't have to understand now what the code means):

```r
iris %>%
    filter(Species == "setosa") %>%
    extract2("Sepal.Length") %>%
    is_greater_than(5) %>%
    table() %>%
    prop.table() %>%
    extract2(TRUE) %>%
    `*`(100) %>%
    paste0(., "%")
```

In this section of code, there is a lot that happens (although some R users might still get the gist of the code). Moreover, a single section of code might quickly get much longer and more complicated than the above example. Luckily, the code can added to with annotation. In R, you can annotate with '#'. Any text written after the '#' on the same line will not be run by R and can therefore be used to annotate code. So let's see how we can increase this code's clarity with annotation:

```r
# Calculate proportion of setosa observations with sepal length above 5
iris %>%
    # Keep only setosa species
    filter(Species == "setosa") %>%
    # Keep only the sepal length values
    extract2("Sepal.Length") %>%
    # Determine whether each value is greater than 5 or not
    is_greater_than(5) %>%
    # Count lengths above and below 5
    table() %>%
    # Turn counts into proportions
    prop.table() %>%
    # Keep only proportion for lengths above 5
    extract2(TRUE) %>%
    # Multiply by 100
    `*`(100) %>%
    # Add percentage sign
    paste0(., "%")
```

It is true that annotation increases the length of a script, but it is important to note that the quality of a script is not affected by its length, but it is by its clarity.

::: {.callout-tip appearance="simple"}
You can use annotation for more than just explaining what your code does. You can add information on the general purpose of a script, its author, its creation date. You can add information on why you made a certain decision or add a URL to where you found the solution to a coding problem. It is easy to annotate too little, but difficult to annotate too much.
:::

## Basic mathematic operators and running code
Now let's (finally) see some real code! Let's start with some basic operators:

```r
1 + 1   # Addition
3 - 1   # Substraction
2 * 3   # Multiplication
8 / 2   # Division
8 %% 2  # Modulo
```

R will follow the [conventional order of mathematic operation](https://en.wikipedia.org/wiki/Order_of_operations#Programming_languages).

However, these operators are useless if we do not actually run the code. To run a section of code, put your cursor in the code section (can be anywhere) and press ctrl + enter to run the code. If you want to run a specific part of the code, instead of a whole section, you can select the part you want to run and then use ctrl + enter again, to run only the selected part. 

The results of the selected code can be found in the console. If the code takes some time, you can see it is done when a new line of the console starts with >.

::: {.callout-important appearance="simple"}
If you select a specific part of code to run, make sure to be inclusive! For instance, if you forget to select an enclosing paranthesis, the selected code will be put in the console, but it will not be run. You can see that this happened if a new line in the console starts with +.
:::

If we run the example code for the basic mathematic operators, we will get the following results:
```{r}
#| echo: false
1 + 1   # Addition
3 - 1   # Substraction
2 * 3   # Multiplication
8 / 2   # Division
8 %% 2  # Modulo
```

Before each result, you can see `[1]`. This indicates that that specific line of code starts with the n^th^ result. When a single code starts printing multiple results, this can help identify what n a certain result is.

::: {#fig-console layout-ncol=2}
![Ready](images/console_ready.png){#fig-ready fig-alt="ready console" width=45%}

![Waiting for input to finish](images/console_waiting.png){#fig-waiting fig-alt="waiting console" width=45%}

Console states
:::

## Functions
Now that we know the basic mathematic operators, we could calculate the standard deviation. For example, for the numbers 3, 8, 3, 7 and 1, we could do the following:

```{r}
#| code-fold: false
# Calculate the mean
(3 + 8 + 3 + 7 + 1) / 5

# Use the calculated mean to calculate the standard deviation
(((3 - 4.4) ^ 2 + (8 - 4.4) ^ 2 + (3 - 4.4) ^ 2 + (7 - 4.4) ^ 2 + (1 - 4.4) ^ 2) / (5 - 1)) ^ 0.5

```

However, with only 5 numbers, this is already a lot of effort. This is where functions come in: R has many built-in keywords that allow you to quickly perform operations and/or calculations on the data, which we call functions. A function has a generic name and is followed by opening and closing brackets. Between the brackets, we can supply so-called arguments (i.e., data and/or specifications). For example, if we wanted to calculate the standard deviation, instead of typing out all the numbers, we could just type the following:

```{r}
#| code-fold: false
# Calculate standard deviation
sd(c(3, 8, 3, 7, 1))
```

:::{.callout-note appearance="simple"}
We will see the `c()` function used when calculating the standard deviation in the next section, so don't worry about it for now!.
::: 




<!-- To do:
•	Functions
•	Basic functions
o	Sum, mean, median, summary, quintiles, min, max, table
•	Storing values in objects
o	Single value
	What operator to use: <- or =
o	Vector (& what is a vector)
o	List
o	Matrices
	Transforming to matrices
o	Dataframes
	Dimensions: nrow, ncol
	Setting column names
	Transforming to data frames
	Transforming matrices to data frames
•	Finding source code of a function
•	Methods() of functions
•	Global environment
o	Get & assign
Errors -->

