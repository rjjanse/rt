{
  "hash": "cfd5fcdb996f4e1d887b8b12a1ef12e7",
  "result": {
    "markdown": "---\ntitle: \"Dplyr\"\n---\n\n\n## Dplyr\n`{dplyr}`, a combination of data and plier, is a package that allows manipulation of data in an easy and efficient way. Whether you want to drop columns, drop rows, create new variables, or change old variables, `{dplyr}` allows you to do this in an intuitive way which requires little code (especially compared to base R). If you have not already installed and loaded `{dplyr}`, you can do so with:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Load dplyr\npacman::p_load(\"dplyr\")\n```\n:::\n\n\nIn this section, we will work with the `starwars` dataset, that is automatically loaded in when you load `{dplyr}`. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Show first 5 rows of starwars\nhead(starwars, n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 14\n  name      height  mass hair_color skin_color eye_color birth_year sex   gender\n  <chr>      <int> <dbl> <chr>      <chr>      <chr>          <dbl> <chr> <chr> \n1 Luke Sky…    172    77 blond      fair       blue            19   male  mascu…\n2 C-3PO        167    75 <NA>       gold       yellow         112   none  mascu…\n3 R2-D2         96    32 <NA>       white, bl… red             33   none  mascu…\n4 Darth Va…    202   136 none       white      yellow          41.9 male  mascu…\n5 Leia Org…    150    49 brown      light      brown           19   fema… femin…\n# ℹ 5 more variables: homeworld <chr>, species <chr>, films <list>,\n#   vehicles <list>, starships <list>\n```\n:::\n:::\n\n\nLet's load the `starwars` data into our Global Environment so that we can easily access it:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Load starwars into Global Environment object called sw\nsw <- starwars\n```\n:::\n\n\nAll `{dplyr}` functions that take a data frame or tibble start with the `.data` argument. Therefore, in all examples below, we first specify our `.data` as `sw` before supplying arguments of the function.\n\n## Renaming and relocating\nBefore we can do anything to the data itself, we should make sure we like the names of the variables. Three of the variables contain the word 'color' (`hair_color`, `skin_color`, `eye_color`). However, we might think it is intuitive enough that these variables indicate colour, so maybe we want to change those names. For this we can use the function `rename()`. In `rename()`, we specify any number of arguments we want, where the left hand side of the argument indicates the new column name and the righth and side of the argument indicates the column that needs to be changed (and therefore the old column name). The right hand side can also be the position of the column (e.g., 2 for the second column).\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Rename variables\nsw <- rename(sw, hair = hair_color, skin = skin_color, eye = eye_color)\n```\n:::\n\n\n:::{.callout-tip appearance=\"simple\"}\nMany functions, among which functions in `{dplyr}` like `rename()` have an argument called `...`. This ellipsis simply means that you can supply any number of arguments of the type that the function uses. For `rename()`, this means we can supply an endless list of variables to be renamed.\n:::\n\nNow our data has some changed names, but we are not done yet. It might also be preferable that sex and gender are mentioned immediately after the name. To do this, we can simply use `relocate()`. In `relocate()`, we specify a group of columns and specify before (argument `.before`) or after (argument `.after`) which column they should be placed.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Relocate variables\nsw <- relocate(sw, sex:gender, .after = name)\n\n# This has the same effect\nsw <- relocate(sw, c(sex, gender), .before = height)\n```\n:::\n\n\n## Filtering and selecting\nNow that our data is a bit more how we (or I?) wanted it, we can also determine whether there are some columns or rows that we do not actually want or need. First of, because I am not interested in any data from outside the starwars universe, we can remove the column `films`. To do this, we use `select()`, which allows us to either specify the columns we want to keep, or specify the columns we want to drop. To keep columns, we simply name them and to drop columns we name them with a dash/minus sign before (-).\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Drop films column\nsw <- select(sw, -films)\n\n# This does the same thing\nsw <- select(sw, name:species, vehicles:starships)\n```\n:::\n\n\nAdditionally, I am not interested in any character (i.e., row) of who we do not know the mass or who is from Tatooine. Tatooine is full of sand and I don't like sand. It's coarse and rough. To remove rows, we can use the `filter()` function. In `filter()`, we supply conditions to which rows must adhere to stay. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Remove rows with missing mass or with characters from Tatooine\nsw <- filter(sw, !is.na(mass) & homeworld != \"Tatooine\")\n```\n:::\n\n\nHere, we use `is.na()` to see what rows are missing in the column `mass` and then take the reverse (!). Additionally (&), the homeworld should not equal (!=) Tatooine.\n\n## The pipe: `%>%`\nBefore we continue with some of the most important `{dplyr}` functions, we should talk about the pipe operator `%>%`. Although `%>%` is not originally from `{dplyr}` but instead imported from `{magrittr}` that we will discuss after this section.\n\nNormally, if we wanted to apply multiple functions at the same time (for instance, `filter()` and `select()` after one another), we would nest the functions:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Keep only the birth year column and then keep only birth years above 100\nfilter(select(starwars, birth_year), birth_year > 100)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 1\n  birth_year\n       <dbl>\n1        112\n2        200\n3        600\n4        896\n5        102\n```\n:::\n:::\n\n\nHowever, this quickly becomes unreadable. With `%>%`, we can transform this into more readable code. What `%>%` does is that it takes the outputted result from the previous function and feeds it into an argument in the next function called `.data` or `data` (if this argument is available). We will go into more detail in [`{magrittr}`](magrittr.qmd).\n\nSo, with `%>%`, we can rewrite the above code as:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Take starwars data\nstarwars %>%\n    # Keep only birth year column\n    select(birth_year) %>%\n    # Keep only birth years above 100\n    filter(birth_year > 100)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 1\n  birth_year\n       <dbl>\n1        112\n2        200\n3        600\n4        896\n5        102\n```\n:::\n:::\n\n\n:::{.callout-tip appearance=\"simple\"}\nSome more about annotation: with pipe operators, we can make our code much clearer and with that also our annotations. My personal preference is to annotate each new function after a pipe, so that it becomes even more readable. These annotations might just describe what we are doing, or give more details about why we are doing it. This makes it understandable to people who might not understand R equally well or know the functions we are using and allows better understanding of choices we made.\n:::\n\n## Mutating and conditionals\nNow that we have the data that we want, we might want to create some new variables. For instance, it would be interesting to know the Body Mass Index (BMI) of the characters, which we can calculate because we have height and mass. We can do that with `mutate()`. In this function, we can specify any number of arguments, with the left hand side of the argument being the name of the new variable and the right hand side being the value it should take.\n\nA great characteristic of `mutate()` is that we can immediately use a variable we just calculted within the same `mutate()` function call. For instance, if we calculate BMI, we can immediately create a variable that indicates whether according to commonly used BMI dichotomisation for humans, a character classifies as overweight or not.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Calculate BMI and overweight indicator\nsw <- mutate(sw, \n             # Change height to meters\n             height = height / 100,\n             # Calculate BMI\n             bmi = mass / height ^ 2,\n             # Create indicator for overweight\n             overweight = ifelse(bmi >= 25, 1, 0))\n\n# Show summary of BMI\nsummary(sw[[\"bmi\"]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  12.89   19.48   23.83   32.47   25.86  443.43 \n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n# Show table of overweight\ntable(sw[[\"overweight\"]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n 0  1 \n32 16 \n```\n:::\n:::\n\n\nWhat we used to create the overweight variable was an if-else clause, which is a commonly used clause in programming. Simply, it checks whether a condition is true. If a condition is true, then it does A, otherwise it does B. In this case, `ifelse()` checks the condition `bmi >= 25`. If that condition is `TRUE`, then the variable `overweight` is assigned a 1, otherwise a 0.\n\n//Something about nesting ifelse() and case_when()\n\n## Grouping and slicing\nNow that we know about pipe operators, we can apply them to some nice `{dplyr}` functions. Sometimes, we might want \n\n\n## Animations\n\n## Other useful functions\n\n## Extensions\n### `{dtplyr}`\n\n\n### `{dbplyr}`",
    "supporting": [
      "dplyr_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}