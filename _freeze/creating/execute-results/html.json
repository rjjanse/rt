{
  "hash": "22fd451ececff07f0ec4be1ec701f2e0",
  "result": {
    "markdown": "---\ntitle: \"Creating and storing data\"\n---\n\n\n## Annotation\nLet's get started in R. Before we write any code, we should discuss the importance of annotation. When you are writing code it might seem clear to you what each line does, but if someone else reads your code or you look back at your code after a while, it might not seem so clear anymore. To allow others and your future-self to efficiently check, read, and re-use your code, it is important to **extensively** annotate your code. Let's see some unannotated code (you don't have to understand now what the code means):\n\n```r\niris %>%\n    filter(Species == \"setosa\") %>%\n    extract2(\"Sepal.Length\") %>%\n    is_greater_than(5) %>%\n    table() %>%\n    prop.table() %>%\n    extract2(TRUE) %>%\n    `*`(100) %>%\n    paste0(., \"%\")\n```\n\nIn this section of code, there is a lot that happens (although some R users might still get the gist of the code). Moreover, a single section of code might quickly get much longer and more complicated than the above example. Luckily, the code can added to with annotation. In R, you can annotate with '#'. Any text written after the '#' on the same line will not be run by R and can therefore be used to annotate code. So let's see how we can increase this code's clarity with annotation:\n\n```r\n# Calculate proportion of setosa observations with sepal length above 5\niris %>%\n    # Keep only setosa species\n    filter(Species == \"setosa\") %>%\n    # Keep only the sepal length values\n    extract2(\"Sepal.Length\") %>%\n    # Determine whether each value is greater than 5 or not\n    is_greater_than(5) %>%\n    # Count lengths above and below 5\n    table() %>%\n    # Turn counts into proportions\n    prop.table() %>%\n    # Keep only proportion for lengths above 5\n    extract2(TRUE) %>%\n    # Multiply by 100\n    `*`(100) %>%\n    # Add percentage sign\n    paste0(., \"%\")\n```\n\nIt is true that annotation increases the length of a script, but it is important to note that the quality of a script is not affected by its length, but it is by its clarity.\n\n::: {.callout-tip appearance=\"simple\"}\nYou can use annotation for more than just explaining what your code does. You can add information on the general purpose of a script, its author, its creation date. You can add information on why you made a certain decision or add a URL to where you found the solution to a coding problem. It is easy to annotate too little, but difficult to annotate too much.\n:::\n\n## Basic mathematic operators and running code\nNow let's (finally) see some real code! Let's start with some basic operators:\n\n```r\n1 + 1   # Addition\n3 - 1   # Substraction\n2 * 3   # Multiplication\n8 / 2   # Division\n8 %% 2  # Modulo\n```\n\nR follows the [conventional order of mathematic operation](https://en.wikipedia.org/wiki/Order_of_operations#Programming_languages).\n\nHowever, these operators are useless if we do not actually run the code. To run a section of code, put your cursor in the code section (can be anywhere) and press ctrl + enter to run the code. If you want to run a specific part of the code, instead of a whole section, you can select the part you want to run and then use ctrl + enter again, to run only the selected part. \n\nThe results of the selected code can be found in the console. If the code takes some time to run, you can see it is done when a new line of the console starts with > (@fig-ready).\n\n::: {.callout-important appearance=\"simple\"}\nIf you select a specific part of code to run, make sure to be inclusive! For instance, if you forget to select an enclosing paranthesis, the selected code will be put in the console, but it will not be run. You can see that this happened if a new line in the console starts with + (@fig-waiting). To cancel a waiting command, you can press esc.\n:::\n\nIf we run the example code for the basic mathematic operators, we will get the following results:\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n1 + 1   # Addition\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n3 - 1   # Substraction\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n2 * 3   # Multiplication\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n8 / 2   # Division\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n8 %% 2  # Modulo\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n\nBefore each result, you can see `[1]`. This indicates that that specific line of code starts with the n^th^ result. When a single code starts printing multiple results, this can help identify what n a certain result is.\n\n::: {#fig-console layout-ncol=2}\n![Ready](images/console_ready.png){#fig-ready fig-alt=\"ready console\" width=45%}\n\n![Waiting for input to finish](images/console_waiting.png){#fig-waiting fig-alt=\"waiting console\" width=45%}\n\nConsole states\n:::\n\n## Functions\nNow that we know the basic mathematic operators, we could calculate the standard deviation. For example, for the numbers 3, 8, 3, 7 and 1, we could do the following:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Calculate the mean\n(3 + 8 + 3 + 7 + 1) / 5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4.4\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Use the calculated mean to calculate the standard deviation\n(((3 - 4.4) ^ 2 + (8 - 4.4) ^ 2 + (3 - 4.4) ^ 2 + (7 - 4.4) ^ 2 + (1 - 4.4) ^ 2) / (5 - 1)) ^ 0.5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.966479\n```\n:::\n:::\n\n\n::: {.column-margin}\nA sample's standard deviation $s$ is obtained by calculating:\n\n$$\\sqrt\\frac{\\sum{(x-\\overline{x})^2}}{n-1}$$\n:::\n\nHowever, with only 5 numbers, this is already a lot of effort. This is where functions come in: R has many built-in keywords that allow you to quickly perform operations and/or calculations on the data, which we call functions. A function has a generic name and is followed by opening and closing brackets. Between the brackets, we can supply so-called arguments (i.e., data and/or specifications). For example, if we wanted to calculate the standard deviation, instead of typing out all the numbers, we could just type the following:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Calculate standard deviation\nsd(c(3, 8, 3, 7, 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.966479\n```\n:::\n:::\n\n\n:::{.callout-note appearance=\"simple\"}\nIn the standard deviation function, we use the `c()` function. Later we will elaborate on this, but for now it is enough to remember that `c()` creates a **c**ollection of data, which is more often called an object.\n::: \n\nLet's see some standard functions that will be of great help to you.\n\n### Sum\n`sum()`, as it name suggests, sums the supplied values. It has the following arguments:\n\n- `...`: the ellipsis indicates that any number of values can be supplied here. The sum function can take numeric values, integers, and booleans/logicals (i.e., it can sum the amount of `TRUE`s).\n\n- `na.rm = FALSE`: na.rm indicates whether any missing values should be dropped. By default, this is `FALSE`, meaning that the function will return `NA` if there is any `NA`s present in the data you are trying to sum. If you want to sum all valid values (thus drop all `NA`s), you can specify `na.rm = TRUE`.\n\nSee the below examples:\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nsum(3, 4, 5, 6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 18\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\nsum(3, NA, 5, 6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\nsum(3, NA, 5, 6, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 14\n```\n:::\n:::\n\n\n:::{.callout-note appearance=\"simple\"}\nIn the `sum()` function, `na.rm` has the default value `FALSE`. This means that this argument does not have to be defined. If we would not define it, it would just use `FALSE`.\n:::\n\n### Mean and median\nTo get the mean or median from some data, you can use the `mean()` and `median()` functions. `mean()` has the following arguments:\n\n- `x`: a collection (or object) of data containing the data for which a mean should be calculated.\n\n- `trim = 0`: what proportion of the outskirts of the data should be trimmed (e.g., 0.05 trims 5% of data on each side). It defaults to 0.\n\n- `na.rm = FALSE`: whether `NA`s should be dropped (as in `sum()`)\n\n`median()` has the same arguments, except that it doesn't have `trim`.\n\nHere are some examples:\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nmean(c(3, 4, 8, 3, 0, 4, 7, 8, 3, 1, 1044))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 98.63636\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\nmean(c(3, 4, 8, 3, 0, 4, 7, 8, 3, 1, 1044), trim = 0.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4.555556\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\nmedian(c(3, 4, 8, 3, 0, 4, 7, 8, 3, 1, 1044))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n\n:::{.callout-important appearance=\"simple\"}\nNotice how with the mean, we specified that 0.1 was the value for `trim`, but we did not specify that `c(3, 4, 8, 3, 0, 4, 7, 8, 3, 1, 1044)` was the value for `x`. This is because R inputs values for arguments in order: the first supplied value will be used for the first argument, the second supplied value will be used for the second argument, etc. However, sometimes I do not want to specify the second value, but I do want to specify the third value. In this case I can name the argument as in `trim = 0.1`, so that R knows the 0.1 is meant for `trim`.\n:::\n\n### Min and max\nNow that we know how to calculate the mean and median from some data, we might also be interest in finding the lowest and highest value (for example, to detect the 1044 outlier). We can do this with `min()` and `max()`, which both take only one argument: `...` as in the `sum()` function. \n\nTo get the minimum and maximum value from the data we just calculated the mean and median of, we could do the following:\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nmin(3, 4, 8, 3, 0, 4, 7, 8, 3, 1, 1044)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\nmax(3, 4, 8, 3, 0, 4, 7, 8, 3, 1, 1044)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1044\n```\n:::\n:::\n\n\n### Summary and quintile\nNow we know how to calculate the mean, median, minimum, and maximum values from some data, but what if we also want to know the 1^st^ and 3^rd^ quartile? Additionally, we do not want to use a function for each separate value. In this case, you can use `summary()`, which calculates the minimum, 1^st^ quartile, mean, median, 3^rd^ quartile, and maximum all at once. The summary function has multiple arguments, but only one is relevant for now:\n\n- `object`: the data of which you want to get a summary.\n\nFor example:\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nsummary(c(3, 4, 8, 3, 0, 4, 7, 8, 3, 1, 1044))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.00    3.00    4.00   98.64    7.50 1044.00 \n```\n:::\n:::\n\n\nHowever, maybe we are more interested in the 1^st^ and 99^th^ quantiles. In that case we could use `quantile()`. You can supply the following arguments to `quantile()`:\n\n- `x`: a collection of data (or object) of which you want to calculate quantiles.\n\n- `probs = seq(0, 1, 0.25)`: the probabilities (or quantiles) you want to calculate. It defaults to `seq(0, 1, 0.25)`, which just means a sequence from 0 to 1 with increments of 0.25.\n\n- `na.rm = FALSE`: whether `NA`s should be dropped.\n\n- `names = TRUE`: whether the output should show the name (or specified quantile).\n\nSo we could do:\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nquantile(c(3, 4, 8, 3, 0, 4, 7, 8, 3, 1, 1044), \n         probs = c(0.01, 0.99))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   1%   99% \n  0.1 940.4 \n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\nquantile(c(3, 4, 8, 3, 0, 4, 7, 8, 3, 1, 1044), \n         probs = c(0.01, 0.99), names = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]   0.1 940.4\n```\n:::\n:::\n\n\n### Table\nWe have now seen some functions that we can use to get some descriptives about continuous data. However, sometimes we just want to count the amount of different observations. For this we can use `table()`. Some of the relevant arguments for the table function are the following:\n\n- `...`: the variables to be supplied to table, as we saw in earlier functions.\n\n- `useNA = c(\"no\", \"ifany\", \"always\")`: should `NA`s be tabulated (conditional on if any are present) or not. The `c(\"no\", \"ifany\", \"always\")`, means that `useNA` takes any of the three following values: `\"no\"`, `\"ifany\"`, or `\"always\"`.\n\nFor example:\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntable(c(TRUE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE, FALSE, NA))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nFALSE  TRUE \n    3     5 \n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\ntable(c(TRUE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE, FALSE, NA), \n      useNA = \"ifany\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nFALSE  TRUE  <NA> \n    3     5     1 \n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\ntable(c(TRUE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE, FALSE), \n      useNA = \"always\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nFALSE  TRUE  <NA> \n    3     5     0 \n```\n:::\n:::\n\n\nYou can also use `table()` to create a cross-table:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntable(c(FALSE, TRUE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE, FALSE), \n      c(TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       \n        FALSE TRUE\n  FALSE     3    1\n  TRUE      3    2\n```\n:::\n:::\n\n\nFor the cross-tabulation, values are compered based on their order in the data you supply (e.g., the first value, `FALSE` in the first set is compared to the first value, `TRUE`, in the second set.)\n\n:::{.callout-tip appearance=\"simple\"}\nWe now went through some arguments for commonly used functions together, but it is good that you know what arguments a function takes and where you can find this. If you want to know more about any function, for example for `sum()`, you can open the documentation by running `?sum`. In the help panel on the lower right in RStudio, you will find the documentation with the function, its default values, elaboration on the arguments it takes, details, and examples. You can also click on a function and press F1 to open the help panel.\n:::\n\n## Storing values\nWe have now seen how we can calculate some values using basic mathematic operators and functions. However, just typing out our data can become quite tiresome, so preferably I would store them in a variable. In R, things that store data are often called subjects. Let's look at some different ways we can store data.\n\n### Single value\nWe can assign a single value by using the `<-` operator (which has the easy keyboard shortcut alt + - in RStudio). To then see the object, we can simply run it. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nx <- sum(4, 9)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 13\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\nx <- 4 + 5\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 9\n```\n:::\n:::\n\n\n:::{.callout-caution appearance=\"simple\"}\nNote that we defined the object `x` twice. When defining an object that already exists, the old object is overridden. \n:::\n\n:::{.callout-tip appearance=\"simple\"}\nTo assign a value to an object, you can also use `=` instead of `<-`. However, this is often unclear and may be confused with defining arguments in functions. It is therefore strongly recommended to only assign objects using `<-`.\n:::\n\n### Vectors\nWhen we want to assign multiple values to a single variable, we can create a vector. There are two simple ways to create a vector. First, we can use the c function (`c()`), that we saw before when discussing functions. `c()` creates a simple collection of any type of value. We call this collection a vector.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nx <- c(4, 6, 9, 3, 2)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 6 9 3 2\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n# Using a vector in the sum function\nsum(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 24\n```\n:::\n:::\n\n\nYou can also create a vector of sequential integers by using `:`:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nx <- 5:17\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  5  6  7  8  9 10 11 12 13 14 15 16 17\n```\n:::\n:::\n\n\nAdditionally, you can create any sequence using the `seq()` function which takes the arguments `from`, `to`, and `by`, meaning respectively the start, finish, and increments of the sequence.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nx <- seq(5, 7, 0.5)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.0 5.5 6.0 6.5 7.0\n```\n:::\n:::\n\n\nWe could also multiply two vectors with each other (given they have the same length) or a vector with a single value:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nx <- 1:5\ny <- 5:1\n\nx * y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 8 9 8 5\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\nx * 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  4  6  8 10\n```\n:::\n:::\n\n\nLastly, you could create a named vector (i.e., each value has a name):\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nx <- c(\"Obs1\" = 42, \"Obs2\" = 28, \"Obs3\" = 91)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nObs1 Obs2 Obs3 \n  42   28   91 \n```\n:::\n:::\n\n\n### Lists\nA list is also a collection of data, but it can store much more than just values, such as vectors, and whole data sets:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nx <- list(head(iris, 3), head(mtcars, 3))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n\n[[2]]\n               mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4     21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710    22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\n```\n:::\n:::\n\n\nHowever, you cannot immediately apply mathematic operators on a list or use a list in data. If we have a list with data (for example different objects), we first have to unlist:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nx <- list(4, 2)\nunlist(x) * 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8 4\n```\n:::\n:::\n\n\nWhen you create a model, they are always stored in lists too, with many information alongside the results. We will come across this later in the tutorial.\n\n### Matrices\nIf we want data with more than one dimension (i.e., columns and rows), we could create a matrix with the matrix function:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nx <- matrix(c(31, 3, 18, 7, 84, 20), nrow = 3, ncol = 2)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]   31    7\n[2,]    3   84\n[3,]   18   20\n```\n:::\n:::\n\n\nWe can also supply a single value that fills the entire matrix:\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nx <- matrix(\"Hello, World!\", nrow = 5, ncol = 3)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]            [,2]            [,3]           \n[1,] \"Hello, World!\" \"Hello, World!\" \"Hello, World!\"\n[2,] \"Hello, World!\" \"Hello, World!\" \"Hello, World!\"\n[3,] \"Hello, World!\" \"Hello, World!\" \"Hello, World!\"\n[4,] \"Hello, World!\" \"Hello, World!\" \"Hello, World!\"\n[5,] \"Hello, World!\" \"Hello, World!\" \"Hello, World!\"\n```\n:::\n:::\n\n\nMatrices are useful because they have multiple dimensions, which allows us to store different variables of the same person in multiple columns along the same row.\n\n### Data frames\nMatrices give us a flexible way to store data with rows and columns, but miss some flexibility when it comes to manipulating the data and performing calculations, loading it into functions, etc. In this case, data frames offer a good solution. Data frames look exactly matrices, but are much easier to manipulate and use for analyses. Data frames are likely what will compose most of the data you use in R.\n\nWe can create a data frame with the `data.frame()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nx <- data.frame(id = 1:5,\n                value1 = c(5, 2, 0, 2, 4),\n                value2 = c(9.4, 8.3, 2.8, 5.6, 2.7))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  id value1 value2\n1  1      5    9.4\n2  2      2    8.3\n3  3      0    2.8\n4  4      2    5.6\n5  5      4    2.7\n```\n:::\n:::\n\n\nWhen working with data frames, there are some useful functions you can use:\n\n- To determine how many rows and columns a data frame (or matrix) has, you can use `nrow()` and `ncol()`.\n\n- To change the row and column names, you can use `rownames()` and `colnames()`. To see how these functions work, you can access the examples in their documentation with `?rownames` and `?colnames`.\n\n- To change a data frame to a matrix or a matrix to a data frame, you can use `as.matrix()` and `as.data.frame()`.\n\n## The global environment\n\n<!--\n•\tStoring values in objects\no\tSingle value\n\tWhat operator to use: <- or =\no\tVector (& what is a vector)\no\tList\no\tMatrices\n\tTransforming to matrices\no\tDataframes\n\tDimensions: nrow, ncol\n\tSetting column names\n\tTransforming to data frames\n\tTransforming matrices to data frames\n•\tFinding source code of a function\n•\tMethods() of functions\n•\tGlobal environment\no\tGet & assign\nErrors -->\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}