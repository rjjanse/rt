{
  "hash": "5b024d515440cd0a48cb6fc768342b41",
  "result": {
    "markdown": "---\ntitle: \"Using data\"\n---\n\n\n## Viewing data\nNow that we have seen some basic R operations, such as functions and creating some data, let's see some ways to access this data and play with it. For this we'll mainly be working with dataframes and matrices. As an example, we will use the `iris` dataset, which is loaded into R by default. You can view the data just by running `iris` in your console:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\niris\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n1            5.1         3.5          1.4         0.2     setosa\n2            4.9         3.0          1.4         0.2     setosa\n3            4.7         3.2          1.3         0.2     setosa\n4            4.6         3.1          1.5         0.2     setosa\n5            5.0         3.6          1.4         0.2     setosa\n6            5.4         3.9          1.7         0.4     setosa\n7            4.6         3.4          1.4         0.3     setosa\n8            5.0         3.4          1.5         0.2     setosa\n9            4.4         2.9          1.4         0.2     setosa\n10           4.9         3.1          1.5         0.1     setosa\n11           5.4         3.7          1.5         0.2     setosa\n12           4.8         3.4          1.6         0.2     setosa\n13           4.8         3.0          1.4         0.1     setosa\n14           4.3         3.0          1.1         0.1     setosa\n15           5.8         4.0          1.2         0.2     setosa\n16           5.7         4.4          1.5         0.4     setosa\n17           5.4         3.9          1.3         0.4     setosa\n18           5.1         3.5          1.4         0.3     setosa\n19           5.7         3.8          1.7         0.3     setosa\n20           5.1         3.8          1.5         0.3     setosa\n21           5.4         3.4          1.7         0.2     setosa\n22           5.1         3.7          1.5         0.4     setosa\n23           4.6         3.6          1.0         0.2     setosa\n24           5.1         3.3          1.7         0.5     setosa\n25           4.8         3.4          1.9         0.2     setosa\n26           5.0         3.0          1.6         0.2     setosa\n27           5.0         3.4          1.6         0.4     setosa\n28           5.2         3.5          1.5         0.2     setosa\n29           5.2         3.4          1.4         0.2     setosa\n30           4.7         3.2          1.6         0.2     setosa\n31           4.8         3.1          1.6         0.2     setosa\n32           5.4         3.4          1.5         0.4     setosa\n33           5.2         4.1          1.5         0.1     setosa\n34           5.5         4.2          1.4         0.2     setosa\n35           4.9         3.1          1.5         0.2     setosa\n36           5.0         3.2          1.2         0.2     setosa\n37           5.5         3.5          1.3         0.2     setosa\n38           4.9         3.6          1.4         0.1     setosa\n39           4.4         3.0          1.3         0.2     setosa\n40           5.1         3.4          1.5         0.2     setosa\n41           5.0         3.5          1.3         0.3     setosa\n42           4.5         2.3          1.3         0.3     setosa\n43           4.4         3.2          1.3         0.2     setosa\n44           5.0         3.5          1.6         0.6     setosa\n45           5.1         3.8          1.9         0.4     setosa\n46           4.8         3.0          1.4         0.3     setosa\n47           5.1         3.8          1.6         0.2     setosa\n48           4.6         3.2          1.4         0.2     setosa\n49           5.3         3.7          1.5         0.2     setosa\n50           5.0         3.3          1.4         0.2     setosa\n51           7.0         3.2          4.7         1.4 versicolor\n52           6.4         3.2          4.5         1.5 versicolor\n53           6.9         3.1          4.9         1.5 versicolor\n54           5.5         2.3          4.0         1.3 versicolor\n55           6.5         2.8          4.6         1.5 versicolor\n56           5.7         2.8          4.5         1.3 versicolor\n57           6.3         3.3          4.7         1.6 versicolor\n58           4.9         2.4          3.3         1.0 versicolor\n59           6.6         2.9          4.6         1.3 versicolor\n60           5.2         2.7          3.9         1.4 versicolor\n61           5.0         2.0          3.5         1.0 versicolor\n62           5.9         3.0          4.2         1.5 versicolor\n63           6.0         2.2          4.0         1.0 versicolor\n64           6.1         2.9          4.7         1.4 versicolor\n65           5.6         2.9          3.6         1.3 versicolor\n66           6.7         3.1          4.4         1.4 versicolor\n67           5.6         3.0          4.5         1.5 versicolor\n68           5.8         2.7          4.1         1.0 versicolor\n69           6.2         2.2          4.5         1.5 versicolor\n70           5.6         2.5          3.9         1.1 versicolor\n71           5.9         3.2          4.8         1.8 versicolor\n72           6.1         2.8          4.0         1.3 versicolor\n73           6.3         2.5          4.9         1.5 versicolor\n74           6.1         2.8          4.7         1.2 versicolor\n75           6.4         2.9          4.3         1.3 versicolor\n76           6.6         3.0          4.4         1.4 versicolor\n77           6.8         2.8          4.8         1.4 versicolor\n78           6.7         3.0          5.0         1.7 versicolor\n79           6.0         2.9          4.5         1.5 versicolor\n80           5.7         2.6          3.5         1.0 versicolor\n81           5.5         2.4          3.8         1.1 versicolor\n82           5.5         2.4          3.7         1.0 versicolor\n83           5.8         2.7          3.9         1.2 versicolor\n84           6.0         2.7          5.1         1.6 versicolor\n85           5.4         3.0          4.5         1.5 versicolor\n86           6.0         3.4          4.5         1.6 versicolor\n87           6.7         3.1          4.7         1.5 versicolor\n88           6.3         2.3          4.4         1.3 versicolor\n89           5.6         3.0          4.1         1.3 versicolor\n90           5.5         2.5          4.0         1.3 versicolor\n91           5.5         2.6          4.4         1.2 versicolor\n92           6.1         3.0          4.6         1.4 versicolor\n93           5.8         2.6          4.0         1.2 versicolor\n94           5.0         2.3          3.3         1.0 versicolor\n95           5.6         2.7          4.2         1.3 versicolor\n96           5.7         3.0          4.2         1.2 versicolor\n97           5.7         2.9          4.2         1.3 versicolor\n98           6.2         2.9          4.3         1.3 versicolor\n99           5.1         2.5          3.0         1.1 versicolor\n100          5.7         2.8          4.1         1.3 versicolor\n101          6.3         3.3          6.0         2.5  virginica\n102          5.8         2.7          5.1         1.9  virginica\n103          7.1         3.0          5.9         2.1  virginica\n104          6.3         2.9          5.6         1.8  virginica\n105          6.5         3.0          5.8         2.2  virginica\n106          7.6         3.0          6.6         2.1  virginica\n107          4.9         2.5          4.5         1.7  virginica\n108          7.3         2.9          6.3         1.8  virginica\n109          6.7         2.5          5.8         1.8  virginica\n110          7.2         3.6          6.1         2.5  virginica\n111          6.5         3.2          5.1         2.0  virginica\n112          6.4         2.7          5.3         1.9  virginica\n113          6.8         3.0          5.5         2.1  virginica\n114          5.7         2.5          5.0         2.0  virginica\n115          5.8         2.8          5.1         2.4  virginica\n116          6.4         3.2          5.3         2.3  virginica\n117          6.5         3.0          5.5         1.8  virginica\n118          7.7         3.8          6.7         2.2  virginica\n119          7.7         2.6          6.9         2.3  virginica\n120          6.0         2.2          5.0         1.5  virginica\n121          6.9         3.2          5.7         2.3  virginica\n122          5.6         2.8          4.9         2.0  virginica\n123          7.7         2.8          6.7         2.0  virginica\n124          6.3         2.7          4.9         1.8  virginica\n125          6.7         3.3          5.7         2.1  virginica\n126          7.2         3.2          6.0         1.8  virginica\n127          6.2         2.8          4.8         1.8  virginica\n128          6.1         3.0          4.9         1.8  virginica\n129          6.4         2.8          5.6         2.1  virginica\n130          7.2         3.0          5.8         1.6  virginica\n131          7.4         2.8          6.1         1.9  virginica\n132          7.9         3.8          6.4         2.0  virginica\n133          6.4         2.8          5.6         2.2  virginica\n134          6.3         2.8          5.1         1.5  virginica\n135          6.1         2.6          5.6         1.4  virginica\n136          7.7         3.0          6.1         2.3  virginica\n137          6.3         3.4          5.6         2.4  virginica\n138          6.4         3.1          5.5         1.8  virginica\n139          6.0         3.0          4.8         1.8  virginica\n140          6.9         3.1          5.4         2.1  virginica\n141          6.7         3.1          5.6         2.4  virginica\n142          6.9         3.1          5.1         2.3  virginica\n143          5.8         2.7          5.1         1.9  virginica\n144          6.8         3.2          5.9         2.3  virginica\n145          6.7         3.3          5.7         2.5  virginica\n146          6.7         3.0          5.2         2.3  virginica\n147          6.3         2.5          5.0         1.9  virginica\n148          6.5         3.0          5.2         2.0  virginica\n149          6.2         3.4          5.4         2.3  virginica\n150          5.9         3.0          5.1         1.8  virginica\n```\n:::\n:::\n\n\nAlthough this is fine for small datasets, and seems okay for the `iris` datset, data will easily be too large to properly display in the console. In that case, we can choose to see only the beginning or the end of the data, using the `head()` and `tail()` functions. With these functions, you can specify the number of rows in a certain dataset that you want to see. For example, to see the first 4 and the last 5 rows of the iris dataset, we can do the following:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nhead(iris, n = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\ntail(iris, n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n146          6.7         3.0          5.2         2.3 virginica\n147          6.3         2.5          5.0         1.9 virginica\n148          6.5         3.0          5.2         2.0 virginica\n149          6.2         3.4          5.4         2.3 virginica\n150          5.9         3.0          5.1         1.8 virginica\n```\n:::\n:::\n\n\n:::{.callout-important appearance=\"simple\"}\nNote that because iris is loaded in by default, it does not appear in your global environment. To have it appear there, you can simply run:\n```r\niris <- iris\n```\n\nor use the `data()` function:\n```r\ndata(iris)\n```\n\n:::\n\nThis is already much clearer. Nonetheless, we might want to see the whole data, for example to quickly look for inconsistencies. You can do this just by clicking on the name of the data in your global environment, or by using the `view()` function:\n\n```r\nview(iris)\n```\n\nWhen we use `view()` or open data from the global environment, RStudio offers as some quick tools to get a better overview of our data. After opening the data, you will see something similar to @fig-view, where you can see some areas of interest demarcated.\n\n![Viewing data](images/view.png){#fig-view fig-alt=\"Viewing data\" fig-align=\"center\"}\n\nWe can now scroll through the data and see all columns. If you wonder how many rows and columns you have, you can see this at the bottom of the window. The viewer will only show 50 columns at a time, but you can click through the columns if you have more than 50. If you want to see only entries that meet a certain condition, you can press the filter button at the top of the viewer to filter certain values. Lastly, you can sort a column as ascending or descending by clicking on the little arrows to the right of the column name. Note that any operation you perform on the data in the viewer (sorting, filtering), does not affect the actual data, only the data you see. In other words, you only manipulate what you see in the data, not the data itself.\n\n## Comparing values\nBefore we see how to access the data, let's take a sidestep to see how we can compare values in R. To compare values and get returned `TRUE` or `FALSE` (called Booleans) there are some important operators:\n\n- `>`: Greater than; is the value before the operator greater than the value after the operator.\n- `<`: Smaller than; is the value before the operator smaller than the value after the operator.\n- `>=`: Greater than or equal to; is the value before the operator greater than or equal to the value after the operator.\n- `<=`: Smaller than or equal to; is the value before the operator smaller than or equal to the value after the operator.\n- `==`: Equal; is the value before the operator equal to the value after the operator.\n- `!=`: Not equal; is the value before the operator not equal to the value after the operator.\n\nLet's see some examples of using these operators:\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Greater than\n5 > 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n# Smaller than\n3 < 5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n# Greater than or equal to\n3 >= 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n# Smaller than or equal to\n3 <= 5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n# Equal\n3 == 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n# Not equal\n3 != 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n## Boolean operators\nNow that we can compare values and get returned `TRUE` or `FALSE`, we can also make multiple comparisons using Boolean operators (also know as logical operators). If the conditions specified match, these will return `TRUE`, otherwise `FALSE`.\n\n- `|`: OR; the value before or after the operator should be `TRUE`.\n- `&`: AND; the values before and after the operator should be `TRUE`. \n- `!`: NOT; the match should not be `TRUE`.\n- `xor(x, y)`: XOR; x or y but not x and y; if x is `TRUE`, y should be `FALSE` and vice versa.\n\n@fig-bools shows a visual explanation of the boolean operators, as shown in the book [R for Data Science](https://r4ds.had.co.nz/transform.html#fig:bool-ops).\n\n![Boolean operators](images/bools.png){#fig-bools fig-alt=\"boolean operators\" fig-align=\"center\"}\n\nUsing them works as follows:\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# OR\n3 == 3 | 3 != 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n# AND\n3 == 3 & 3 != 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n# NOT\n!(3 == 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n# True XOR\nxor(TRUE, FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n# False XOR\nxor(FALSE, FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n## Accessing the data\nBack to accessing the data! We now have a data frame with data inside, loaded in our environment. However, how can we actually access that data? For that, we can 'subset' the data. There is three ways we can do that:\n\n### Dollar operator: $\nThe dollar operator, `$`, allows you to quickly subset a column from the data. This is a good way to have a quick look in your data. For example, if we want to subset the column `Sepal.Length`, we can simply do the following:\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\niris$Sepal.Length\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1\n [19] 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0\n [37] 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5\n [55] 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1\n [73] 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5\n [91] 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3\n[109] 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2\n[127] 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8\n[145] 6.7 6.7 6.3 6.5 6.2 5.9\n```\n:::\n:::\n\n\nAs you can see, this returns a vector with the values. \n\n### Single brackets: []\nImagine we want a specific row, a specific column, or even a specific cell from our data. In that case, `$` is insufficient. Luckily, we can use single brackets: `[]`. When using single brackets on a data frame, we can put two things in-between the brackets: the row-number we are interested in and the column we are interested in. These can be both index numbers and row/column names. If we want to select all rows or all columns, we can leave that argument empty. Let's see some examples:\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Select the value in the 14th row and 4th column\niris[14, 4]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n# Select the second column by name with all rows\niris[, \"Sepal.Width\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] 3.5 3.0 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 3.7 3.4 3.0 3.0 4.0 4.4 3.9 3.5\n [19] 3.8 3.8 3.4 3.7 3.6 3.3 3.4 3.0 3.4 3.5 3.4 3.2 3.1 3.4 4.1 4.2 3.1 3.2\n [37] 3.5 3.6 3.0 3.4 3.5 2.3 3.2 3.5 3.8 3.0 3.8 3.2 3.7 3.3 3.2 3.2 3.1 2.3\n [55] 2.8 2.8 3.3 2.4 2.9 2.7 2.0 3.0 2.2 2.9 2.9 3.1 3.0 2.7 2.2 2.5 3.2 2.8\n [73] 2.5 2.8 2.9 3.0 2.8 3.0 2.9 2.6 2.4 2.4 2.7 2.7 3.0 3.4 3.1 2.3 3.0 2.5\n [91] 2.6 3.0 2.6 2.3 2.7 3.0 2.9 2.9 2.5 2.8 3.3 2.7 3.0 2.9 3.0 3.0 2.5 2.9\n[109] 2.5 3.6 3.2 2.7 3.0 2.5 2.8 3.2 3.0 3.8 2.6 2.2 3.2 2.8 2.8 2.7 3.3 3.2\n[127] 2.8 3.0 2.8 3.0 2.8 3.8 2.8 2.8 2.6 3.0 3.4 3.1 3.0 3.1 3.1 3.1 2.7 3.2\n[145] 3.3 3.0 2.5 3.0 3.4 3.0\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n# Select the value in the 11th row and 4th column by index and name\niris[11, \"Petal.Width\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.2\n```\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## Meow?\nWhile writing this tutorial, my cat walked on my keyboard and decided she wanted to add the following:\n\nckxcccccccccccccccccccccccccccccccccccccc[[[[[[[['xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc.9¿']]]]]]]]\n\n:::\n\nNow we can go even further with our brackets. When we subset our data frame once, we get a vector of values. Imagine we want to subset the 4^th^ value of the column `Sepal.Width`, we can simply do:\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\niris[, \"Sepal.Width\"][4]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3.1\n```\n:::\n:::\n\n\nHowever, our fun doesn't stop here! What if we didn't want the 4^th^ value, but all values larger than 3.0? Easy; let's see how it works:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# We can get a vector of the column Sepal.Width as we saw before\niris[, \"Sepal.Width\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] 3.5 3.0 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 3.7 3.4 3.0 3.0 4.0 4.4 3.9 3.5\n [19] 3.8 3.8 3.4 3.7 3.6 3.3 3.4 3.0 3.4 3.5 3.4 3.2 3.1 3.4 4.1 4.2 3.1 3.2\n [37] 3.5 3.6 3.0 3.4 3.5 2.3 3.2 3.5 3.8 3.0 3.8 3.2 3.7 3.3 3.2 3.2 3.1 2.3\n [55] 2.8 2.8 3.3 2.4 2.9 2.7 2.0 3.0 2.2 2.9 2.9 3.1 3.0 2.7 2.2 2.5 3.2 2.8\n [73] 2.5 2.8 2.9 3.0 2.8 3.0 2.9 2.6 2.4 2.4 2.7 2.7 3.0 3.4 3.1 2.3 3.0 2.5\n [91] 2.6 3.0 2.6 2.3 2.7 3.0 2.9 2.9 2.5 2.8 3.3 2.7 3.0 2.9 3.0 3.0 2.5 2.9\n[109] 2.5 3.6 3.2 2.7 3.0 2.5 2.8 3.2 3.0 3.8 2.6 2.2 3.2 2.8 2.8 2.7 3.3 3.2\n[127] 2.8 3.0 2.8 3.0 2.8 3.8 2.8 2.8 2.6 3.0 3.4 3.1 3.0 3.1 3.1 3.1 2.7 3.2\n[145] 3.3 3.0 2.5 3.0 3.4 3.0\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n# From this vector, we can get per value a Boolean (TRUE or FALSE) whether it is >3.0\niris[, \"Sepal.Width\"] > 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE\n [13] FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [25]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [37]  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE\n [49]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE\n [61] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE\n [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [85] FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [97] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[109] FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE\n[121]  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE\n[133] FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE\n[145]  TRUE FALSE FALSE FALSE  TRUE FALSE\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n# We can use these Booleans to subset the column to only keep values >3.0\niris[, \"Sepal.Width\"][iris[\"Sepal.Width\"] > 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 3.5 3.2 3.1 3.6 3.9 3.4 3.4 3.1 3.7 3.4 4.0 4.4 3.9 3.5 3.8 3.8 3.4 3.7 3.6\n[20] 3.3 3.4 3.4 3.5 3.4 3.2 3.1 3.4 4.1 4.2 3.1 3.2 3.5 3.6 3.4 3.5 3.2 3.5 3.8\n[39] 3.8 3.2 3.7 3.3 3.2 3.2 3.1 3.3 3.1 3.2 3.4 3.1 3.3 3.6 3.2 3.2 3.8 3.2 3.3\n[58] 3.2 3.8 3.4 3.1 3.1 3.1 3.1 3.2 3.3 3.4\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n## To make it more readable, we could of course store the Booleans in their own vector which we use to subset\n# Create vector with Booleans\nlarger_than_3 <- iris[, \"Sepal.Width\"] > 3\n\n# Subset Sepal.Width\niris[, \"Sepal.Width\"][larger_than_3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 3.5 3.2 3.1 3.6 3.9 3.4 3.4 3.1 3.7 3.4 4.0 4.4 3.9 3.5 3.8 3.8 3.4 3.7 3.6\n[20] 3.3 3.4 3.4 3.5 3.4 3.2 3.1 3.4 4.1 4.2 3.1 3.2 3.5 3.6 3.4 3.5 3.2 3.5 3.8\n[39] 3.8 3.2 3.7 3.3 3.2 3.2 3.1 3.3 3.1 3.2 3.4 3.1 3.3 3.6 3.2 3.2 3.8 3.2 3.3\n[58] 3.2 3.8 3.4 3.1 3.1 3.1 3.1 3.2 3.3 3.4\n```\n:::\n:::\n\n\n### Double brackets: [[]]\nInstead of single brackets, we can also use double brackets. So what is the difference? First of all, we can supply only one argument to `[[]]`. In the case of a data frame, this means we cannot subset certain rows, but we can still subset columns. In a vector, we can use `[[]]` as seen before. So what is the difference between single brackets (`[]`) and double brackets (`[[]]`)?\n\nIn vectors and matrices, using double brackets instead of single brackets will drop any attributes and names attached to the data (such as column labels). To subset on a list, double brackets can be used for single values/elements while single brackets return a list of the elements. You may notice that the difference is not big, but it is still good to have heard about it once. More can be found [here](https://stackoverflow.com/questions/1169456/the-difference-between-bracket-and-double-bracket-for-accessing-the-el).\n\n::: {.callout-important appearance=\"simple\"}\nAlthough the `$` operator is a quick way to access some data, it is recommended to not use it in the actual scripts you write. You can use `$` to check out some data in the console or have quickly check something, but in your script you should use `[]` or `[[]]`. This allows you to easily transform code into your own functions (which we will see later). Additionally, dollar operators do not allow logicals, while brackets do.\n:::\n\n## Which\nWhat if we wanted to know not the exact values greater than 3, but the row numbers in the data set? In that case, we could use `which()`:\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nwhich(iris[, \"Sepal.Width\"] > 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]   1   3   4   5   6   7   8  10  11  12  15  16  17  18  19  20  21  22  23\n[20]  24  25  27  28  29  30  31  32  33  34  35  36  37  38  40  41  43  44  45\n[39]  47  48  49  50  51  52  53  57  66  71  86  87 101 110 111 116 118 121 125\n[58] 126 132 137 138 140 141 142 144 145 149\n```\n:::\n:::\n\n\nWe now have the line numbers with which (pun intended) we can subset those values:\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\niris[which(iris[, \"Sepal.Width\"] > 3), \"Sepal.Width\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 3.5 3.2 3.1 3.6 3.9 3.4 3.4 3.1 3.7 3.4 4.0 4.4 3.9 3.5 3.8 3.8 3.4 3.7 3.6\n[20] 3.3 3.4 3.4 3.5 3.4 3.2 3.1 3.4 4.1 4.2 3.1 3.2 3.5 3.6 3.4 3.5 3.2 3.5 3.8\n[39] 3.8 3.2 3.7 3.3 3.2 3.2 3.1 3.3 3.1 3.2 3.4 3.1 3.3 3.6 3.2 3.2 3.8 3.2 3.3\n[58] 3.2 3.8 3.4 3.1 3.1 3.1 3.1 3.2 3.3 3.4\n```\n:::\n:::\n\n\nWe can even use our Boolean operators to show that using `which()` gives the same results as we saw before when not using `which()`:\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\niris[which(iris[, \"Sepal.Width\"] > 3), \"Sepal.Width\"] == iris[, \"Sepal.Width\"][iris[\"Sepal.Width\"] > 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[31] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[46] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[61] TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n```\n:::\n:::\n\n\nThe main advantage of `which()` is that it might be more readable in your code.\n\n## Mutating data\nIt is great to be able to subset specific data from our data frames, but it is much more fun to do some statistics with it! A great thing about the subsetted columns of data is that you can easily perform calculations on them.\n\nFor example, to multiply all values in in the column `Sepal.Width` by 3, we can simply do:\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\niris[[\"Sepal.Width\"]] * 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] 10.5  9.0  9.6  9.3 10.8 11.7 10.2 10.2  8.7  9.3 11.1 10.2  9.0  9.0 12.0\n [16] 13.2 11.7 10.5 11.4 11.4 10.2 11.1 10.8  9.9 10.2  9.0 10.2 10.5 10.2  9.6\n [31]  9.3 10.2 12.3 12.6  9.3  9.6 10.5 10.8  9.0 10.2 10.5  6.9  9.6 10.5 11.4\n [46]  9.0 11.4  9.6 11.1  9.9  9.6  9.6  9.3  6.9  8.4  8.4  9.9  7.2  8.7  8.1\n [61]  6.0  9.0  6.6  8.7  8.7  9.3  9.0  8.1  6.6  7.5  9.6  8.4  7.5  8.4  8.7\n [76]  9.0  8.4  9.0  8.7  7.8  7.2  7.2  8.1  8.1  9.0 10.2  9.3  6.9  9.0  7.5\n [91]  7.8  9.0  7.8  6.9  8.1  9.0  8.7  8.7  7.5  8.4  9.9  8.1  9.0  8.7  9.0\n[106]  9.0  7.5  8.7  7.5 10.8  9.6  8.1  9.0  7.5  8.4  9.6  9.0 11.4  7.8  6.6\n[121]  9.6  8.4  8.4  8.1  9.9  9.6  8.4  9.0  8.4  9.0  8.4 11.4  8.4  8.4  7.8\n[136]  9.0 10.2  9.3  9.0  9.3  9.3  9.3  8.1  9.6  9.9  9.0  7.5  9.0 10.2  9.0\n```\n:::\n:::\n\n\nWe can also multiply all values by a value specific to them. For example. to multiply `Sepal.Width` by `Sepal.Length`, we could run:\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\niris[[\"Sepal.Width\"]] * iris[[\"Sepal.Length\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] 17.85 14.70 15.04 14.26 18.00 21.06 15.64 17.00 12.76 15.19 19.98 16.32\n [13] 14.40 12.90 23.20 25.08 21.06 17.85 21.66 19.38 18.36 18.87 16.56 16.83\n [25] 16.32 15.00 17.00 18.20 17.68 15.04 14.88 18.36 21.32 23.10 15.19 16.00\n [37] 19.25 17.64 13.20 17.34 17.50 10.35 14.08 17.50 19.38 14.40 19.38 14.72\n [49] 19.61 16.50 22.40 20.48 21.39 12.65 18.20 15.96 20.79 11.76 19.14 14.04\n [61] 10.00 17.70 13.20 17.69 16.24 20.77 16.80 15.66 13.64 14.00 18.88 17.08\n [73] 15.75 17.08 18.56 19.80 19.04 20.10 17.40 14.82 13.20 13.20 15.66 16.20\n [85] 16.20 20.40 20.77 14.49 16.80 13.75 14.30 18.30 15.08 11.50 15.12 17.10\n [97] 16.53 17.98 12.75 15.96 20.79 15.66 21.30 18.27 19.50 22.80 12.25 21.17\n[109] 16.75 25.92 20.80 17.28 20.40 14.25 16.24 20.48 19.50 29.26 20.02 13.20\n[121] 22.08 15.68 21.56 17.01 22.11 23.04 17.36 18.30 17.92 21.60 20.72 30.02\n[133] 17.92 17.64 15.86 23.10 21.42 19.84 18.00 21.39 20.77 21.39 15.66 21.76\n[145] 22.11 20.10 15.75 19.50 21.08 17.70\n```\n:::\n:::\n\n\nIt is important to realize that if you are calculating with columns, each mutating value has to be of the same length as the column, or of length 1. If the mutating value is of the same length as the column (e.g., another column), each row in one column is mutated with the row in the other column. If the mutating value is of length 1 (e.g., the number 3), all rows in one column are mutated by the same value.\n\nYou can also perform functions on subsetted data:\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nsummary(iris[[\"Sepal.Width\"]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  2.000   2.800   3.000   3.057   3.300   4.400 \n```\n:::\n:::\n\n\n## Adding data together\nImagine we had two separate data sets: one with all data where the species is setosa and one with all data where the species is versicolor:\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Get setosa data\niris_setosa <- iris[which(iris[[\"Species\"]] == \"setosa\"), ]\n\n# Get versicolor data\niris_versicolor <- iris[which(iris[[\"Species\"]] == \"versicolor\"), ]\n```\n:::\n\n\nIf we wanted to add these data frames together again, we can use `rbind()`, which binds rows together. For `rbind()`, the data frames have to have the same columns, although they do not have to be in the same order.\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Bind data together\niris_setosa_versicolor <- rbind(iris_setosa, iris_versicolor)\n\n# See available values for species\ntable(iris_setosa_versicolor[[\"Species\"]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n    setosa versicolor  virginica \n        50         50          0 \n```\n:::\n:::\n\n\nWe can do the same if we want to bind multiple columns together. In this case, the two data frames should have an equal amount of rows.\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Keep only sepal columns of iris_setosa\niris_setosa_sepal <- iris[, c(\"Sepal.Length\", \"Sepal.Width\")]\n\n# Keep only petal columns of iris_setosa\niris_setosa_petal <- iris[, c(\"Petal.Length\", \"Petal.Width\")]\n\n# Add sepal and petal together again\niris_setosa <- cbind(iris_setosa_sepal, iris_setosa_petal)\n\n# See first rows of the new data\nhead(iris_setosa)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width\n1          5.1         3.5          1.4         0.2\n2          4.9         3.0          1.4         0.2\n3          4.7         3.2          1.3         0.2\n4          4.6         3.1          1.5         0.2\n5          5.0         3.6          1.4         0.2\n6          5.4         3.9          1.7         0.4\n```\n:::\n:::\n\n\nOf course, these examples seem futile as we split data and add it back together. However, `rbind()` and `cbind()` are useful functions when you want to join similar data from different sources.\n\n## Get and assign\nThe last important thing we should discuss about acessing the data are the functions `get()` and `assign()`. Although we can easily assign new data while writing our code (`data <- iris`), at a certain point we might want to automate it (and later on we will see how to do that). In that case, the name of the data we want might vary. When a value might vary, such as a column, it is often possible to use strings, such as `\"iris\"`. However, for assigning data, this does not work:\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ndata <- \"iris\"\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"iris\"\n```\n:::\n:::\n\n\nWe just assigned the string `\"iris\"`, instead of the data `iris`. In this case, `assign()` allows us to achieve our objective:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nassign(\"data\", iris)\nhead(data, n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n```\n:::\n:::\n\n\nIn the same way, if we want to flexibly get data from the global environment, we can use `get()`:\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ndata <- get(\"iris\")\nhead(data, n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n```\n:::\n:::\n\n\n## Value types\nThe last thing to discuss for now are value types. A few times we talked about strings, which is a specific type a value can have in R. The most important value types to know for now are:\n\n- numeric: a _real_ number, for example 1.42, 8.42, and -5.0.\n- integer: an integer, for exapmle 4, -3, and 7. In R, an integer is made explicit with `L`, for example: `10L`.\n- date: a date, such as 2000-02-09, 2000-02-29, and 1912-06-23. Dates are stored behind the scene as an integer showing the distance from a set date. In R, this date is generally 1970-01-01, also known as the origin. Dates in R are generally written in the format yyyy-mm-dd.\n- string: a text, for example \"hello\", \"4\", or \"==\". Strings are always enclosed with single or double quotation marks (', \").\n- logical: a Boolean; `TRUE` or `FALSE`.\n\nTo check the type of a value, we can use `class()`:\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nclass(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\nclass(3L)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\nclass(\"3\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\nAdditionally, we can transform values into different types, using certain functions:\n\n- `as.numeric()`: transform value to numeric.\n- `as.integer()`: transform value to integer.\n- `as.character()`: transform value to string\n- `as.Date()`: transform value to date. This function often needs an origin supplied. Note that Date is written with a capital D.\n\nHere are some examples:\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nas.numeric(\"5\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\nas.integer(3.9)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\nas.character(7)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"7\"\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\nas.Date(\"1992-06-06\", origin = \"1970-01-01\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1992-06-06\"\n```\n:::\n:::\n\n\n## Exercises\n### 1. Store new data\nBesides the dataset `iris`, another available dataset in R is `mtcars`. Load this data into a new data frame called `data` using `assign()`.\n\n::: {.cell}\n\n```{.r .cell-code}\nassign(\"data\", mtcars)\n```\n:::\n\n\n### 2. Subset column\nNow subset the column `disp` and store this in a variable called `var`.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Use dollar operator (generally unrecommended)\nvar <- data$disp\n\n# Use single brackets\nvar <- data[, \"disp\"]\n\n# Use double brackets\nvar <- data[[\"disp\"]]\n```\n:::\n\n\n### 3. Keep certain values\nFrom the variable `var`, keep only values greater than 110.5 and store this in a variable called `var_new`.\n\n::: {.cell}\n\n```{.r .cell-code}\n# With which()\nvar_new <- var[which(var > 110.5)]\n\n# Without which()\nvar_new <- var[var > 110.5]\n```\n:::\n\n\n### 4. Mutate variables\nNow divided all values in `var_new` by 10 and store this in a variable called `var_div`.\n\n::: {.cell}\n\n```{.r .cell-code}\nvar_div <- var_new / 10\n```\n:::\n\n\n### 5. Change values to character\nNow change the values in the variable `var_div` to character values and store these in a variable called `var_char`.\n\n::: {.cell}\n\n```{.r .cell-code}\nvar_char <- as.character(var_div)\n```\n:::\n\n\n### 6. Check character type\nMake sure the first value in the variable `var_char` is not of the type numeric (called `\"numeric\"`).\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(var_char[1]) != \"numeric\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n## Next topic\nWe now know how we can access our data and manipulate it. Next up, we will learn about packages, which allows us to do so much more with our data then we have seen until now.\n\n**Next:** [Packages](packages.qmd)\n",
    "supporting": [
      "using_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}