{
  "hash": "98e15c726fa58c7d011ccc18094c7442",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Magrittr\"\n---\n\n\n\n\n## Magrittr\n`{magrittr}` is a package that allows us to perform more operations within a timeline to make our code more efficient to write and to read. Its main implementation is the pipe (`%>%`) which we already discussed in [Dplyr](dplyr.qmd). However, it also offers as a number of aliases to make operators available in our pipelines.\n\n## `.` and `` ` ``\nBefore we get into the aliases offered by `{magrittr}`, we should realize that we can do without these aliases by using dots (`.`) and backticks (`` ` ``). Here, the dot indicates the data in its current form (i.e. after all previous operations have been applied) and the backticks are put around the operator (e.g. \\grave+\\grave). The operator is then treated as a function (i.e. parentheses are required).\n\nFor instance, take the below data frame:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Create example data\nvec_fib <- c(1, 1, 2, 3, 5, 8, 13, 21, 34, 55)\n```\n:::\n\n\n\n\nIf we want to subtract 3 from all numbers,  multiply by 1.5, and then set all negative values to `NA`, we could do the following:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# First, load magrittr\npacman::p_load(\"magrittr\")\n\n# Start pipeline with vector\nvec_fib %>%\n    # Subtract 3\n    `-`(3) %>%\n    # Multiply by 1.5\n    `*`(1.5) %>%\n    # Set all negative values to NA\n    ifelse(. < 0, NA, .)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]   NA   NA   NA  0.0  3.0  7.5 15.0 27.0 46.5 78.0\n```\n\n\n:::\n:::\n\n\n\n\n## Aliases\nHowever, by using `{magrittr}` allows us functions instead of these operators that improve readability of the code and are easier to use, which are called the aliases. Using those\naliase, we would write the above code as:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Start piepline with vector\nvec_fib %>%\n    # Subtract 3\n    subtract(3) %>%\n    # Multiply by 1.5\n    multiply_by(1.5) %>%\n    # Set all negative values to NA\n    # Here, the alias is perhaps not as useful, as we use . < 0 in a function. The aliases are mostly useful as first function in each piece of the pipeline\n    ifelse(is_less_than(., 0), NA, .)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]   NA   NA   NA  0.0  3.0  7.5 15.0 27.0 46.5 78.0\n```\n\n\n:::\n:::\n\n\n\n\nThe available aliases (also available [here](https://magrittr.tidyverse.org/reference/aliases.html) or in the help function of each alias in R) are:\n\n| **Description**             | **Symbol**      |\n|----------------------------|-------------|\n| extract2                  | `` `[[` ``        |\n| inset                     | `` `[<-` ``      |\n| inset2                    | `` `[[<-` ``     |\n| use_series                | `` `$` ``         |\n| add                       | `` `+` ``        |\n| subtract                  | `` `-` ``        |\n| multiply_by               | `` `*` ``        |\n| raise_to_power            | `` `^` ``        |\n| multiply_by_matrix        | `` `%*%` ``      |\n| divide_by                 | `` `/` ``        |\n| divide_by_int             | `` `%/%` ``      |\n| mod                       | `` `%%` ``       |\n| is_in                     | `` `%in%` ``     |\n| and                       | `` `&` ``        |\n| or                        | `` `|` ``        |\n| equals                    | `` `==` ``       |\n| is_greater_than           | `` `>` ``        |\n| is_weakly_greater_than    | `` `>=` ``       |\n| is_less_than              | `` `<` ``        |\n| is_weakly_less_than       | `` `<=` ``       |\n| not (n'est pas)           | `` `!` ``        |\n| set_colnames              | `` `colnames<-` ``|\n| set_rownames              | `` `rownames<-` ``|\n| set_names                 | `` `names<-` ``  |\n| set_class                 | `` `class<-` ``  |\n| set_attributes            | `` `attributes<-` ``|\n| set_attr                  | `` `attr<-` ``   |\n\n## `|>` \nBesides the pipe implemented by `{magrittr}`, R also offers a native pipe: `|>`. Instead of existing data being called by the dot (`.`), you can use a low dash (`_`). \nAlthough in general the pipes function the same, there are some differences in what they can do and how they are used. The tidyverse has a more elaborate explanation on this topic [here](https://www.tidyverse.org/blog/2023/04/base-vs-magrittr-pipe/) and \nmore details are also available [here](https://stackoverflow.com/questions/67633022/what-are-the-differences-between-rs-native-pipe-and-the-magrittr-pipe) and [here](https://www.r-bloggers.com/2022/01/understanding-the-native-r-pipe-2/).\n\n## Other pipes\nThe `%>%` pipe is not the only pipe `{magrittr}` offers us.\n\n### `%T>%`\nThe Tee pipe returns the left-hand side of the value instead of the right-hand side. In other words, it returns the input into the function instead of the output of the function. This is helpful when we are only interested in the side-effects of a function, instead of its main output (e.g. printing in console).\n\nImagine we are interested in only the description of a .csv file, but not actually loading it into our global environment. In that case, I could use the `read_csv()` function from `{readr}` with the Tee pipe:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Load readr\npacman::p_load(\"readr\")\n\n# Get information on .csv file available online\n\"https://drive.google.com/uc?id=1zO8ekHWx9U7mrbx_0Hoxxu6od7uxJqWw&export=download\" %T>% \n    # Print only data information\n    read_csv()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 100 Columns: 12\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (10): Customer Id, First Name, Last Name, Company, City, Country, Phone...\ndbl   (1): Index\ndate  (1): Subscription Date\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"https://drive.google.com/uc?id=1zO8ekHWx9U7mrbx_0Hoxxu6od7uxJqWw&export=download\"\n```\n\n\n:::\n:::\n\n\n\n\n### `%$%`\nThe exposition pipe gives the names of the data to the next function, which is especially useful if the function does not have a data argument, such as `table()`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Just piping iris into table will not work (commented out to prevent error)\n# iris %>% table(Species)\n\n# Using an exposition pipe, it will work\niris %$% table(Species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSpecies\n    setosa versicolor  virginica \n        50         50         50 \n```\n\n\n:::\n:::\n\n\n\n\n### `$<>$`\nThe assignment pipe is a shorthand pipe for a pipeline that assigns the final value back into the object that was used as the start of the pipeline (i.e. it is short for `x <- x %>% ...`). For example:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Starting value\nx <- 5; y <- 5\n\n# With the assignment operator\nx <- x %>%\n    # Divide by 2\n    divide_by(2)\n\n# With the assignment pipe\ny %<>%\n    # Divide by 2\n    divide_by(2)\n\n# Check whether results are equal\nx == y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n## Exercises\n### 1. Use aliases to change values\nFrom the starwars dataset (available in `{dplyr}`, ), extract the column height and divide by 100.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load dplyr for data\npacman::p_load(\"dplyr\")\n\n# Start pipe with starwars data\nstarwars %>%\n    # Extract column height (unnamed)\n    extract2(\"height\") %>%\n    # Divide by 100\n    divide_by(100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 1.72 1.67 0.96 2.02 1.50 1.78 1.65 0.97 1.83 1.82 1.88 1.80 2.28 1.80 1.73\n[16] 1.75 1.70 1.80 0.66 1.70 1.83 2.00 1.90 1.77 1.75 1.80 1.50   NA 0.88 1.60\n[31] 1.93 1.91 1.70 1.85 1.96 2.24 2.06 1.83 1.37 1.12 1.83 1.63 1.75 1.80 1.78\n[46] 0.79 0.94 1.22 1.63 1.88 1.98 1.96 1.71 1.84 1.88 2.64 1.88 1.96 1.85 1.57\n[61] 1.83 1.83 1.70 1.66 1.65 1.93 1.91 1.83 1.68 1.98 2.29 2.13 1.67 0.96 1.93\n[76] 1.91 1.78 2.16 2.34 1.88 1.78 2.06   NA   NA   NA   NA   NA\n```\n\n\n:::\n:::\n\n\n\n\n### 2. Use different pipes to meddle with starwars\nNow, reassign a frequency table of species to the object name starwars of individuals of at least 2 meters tall using the pipe operators from `{magrittr}`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Start pipe with starwars data and immediately reassign\nstarwars %<>%\n    # Keep only individuals above 2 meters tall\n    filter(height >= 200) %$%\n    # Get table of species\n    table(species)\n\n# Check result\nstarwars\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nspecies\n   Droid   Gungan    Human  Kaleesh Kaminoan   Pau'an Quermian  Wookiee \n       1        2        1        1        2        1        1        2 \n```\n\n\n:::\n:::\n\n\n\n\n## Next topic\nWith that, we discussed a large part of the tidyverse. Although some other packages exist, we discuss these in other sections. Now that we know part of the basic grammar of the tidyverse, we can learn a new set of skills useful for any data analysis.\n\n**Next:** [Plotting](plotting.qmd)",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}