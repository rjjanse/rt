{
  "hash": "11d36e3438b6f16e96c4df369b5bf620",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Tidyr\"\n---\n\n\n\n\n## Tidyr\n`{tidyr}` is a package from the tidyverse that is meant to help you tidy up your data. What is considered 'tidy' data can be read in `vignette(\"tidy-data\")`. In short, tidy data helps you use `{dplyr}` and other tidyverse tools in a way that lets you spend less time on structuring your data and more on performing your analyses.\n\n## Reshaping data\n### Wide to long\nSome analyses require data in long format (i.e. one study participant can have multiple observations which are represented by multiple rows) while data might be retrieved in wide format (i.e. one study participant can have multiple observations which are represented by multiple columns). In such a case, `{tidyr}` offers us `pivot_longer()`.\n\nWe can use `pivot_longer()` in a number of ways, but we must always supply the data in the argument `data`, and the columns to be pivoted in `cols`. In the simplest cases, this will suffice.\n\nAs an example, let's look at `billboard`, a dataset available through `{tidyr}`. `billboard` contains songs ranking the top 100 in the year 2000 with their position in each week after entering the top 100 (wk).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Load tidyr\npacman::p_load(\"tidyr\")\n\n# What does billboard look like?\nhead(billboard)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 79\n  artist      track date.entered   wk1   wk2   wk3   wk4   wk5   wk6   wk7   wk8\n  <chr>       <chr> <date>       <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1 2 Pac       Baby… 2000-02-26      87    82    72    77    87    94    99    NA\n2 2Ge+her     The … 2000-09-02      91    87    92    NA    NA    NA    NA    NA\n3 3 Doors Do… Kryp… 2000-04-08      81    70    68    67    66    57    54    53\n4 3 Doors Do… Loser 2000-10-21      76    76    72    69    67    65    55    59\n5 504 Boyz    Wobb… 2000-04-15      57    34    25    17    17    31    36    49\n6 98^0        Give… 2000-08-19      51    39    34    26    26    19     2     2\n# ℹ 68 more variables: wk9 <dbl>, wk10 <dbl>, wk11 <dbl>, wk12 <dbl>,\n#   wk13 <dbl>, wk14 <dbl>, wk15 <dbl>, wk16 <dbl>, wk17 <dbl>, wk18 <dbl>,\n#   wk19 <dbl>, wk20 <dbl>, wk21 <dbl>, wk22 <dbl>, wk23 <dbl>, wk24 <dbl>,\n#   wk25 <dbl>, wk26 <dbl>, wk27 <dbl>, wk28 <dbl>, wk29 <dbl>, wk30 <dbl>,\n#   wk31 <dbl>, wk32 <dbl>, wk33 <dbl>, wk34 <dbl>, wk35 <dbl>, wk36 <dbl>,\n#   wk37 <dbl>, wk38 <dbl>, wk39 <dbl>, wk40 <dbl>, wk41 <dbl>, wk42 <dbl>,\n#   wk43 <dbl>, wk44 <dbl>, wk45 <dbl>, wk46 <dbl>, wk47 <dbl>, wk48 <dbl>, …\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n# Pivot billboard to long format\nbillboard_long <- pivot_longer(billboard, wk1:wk76)\n\n# Reprint billboard\nhead(billboard_long)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 5\n  artist track                   date.entered name  value\n  <chr>  <chr>                   <date>       <chr> <dbl>\n1 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk1      87\n2 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk2      82\n3 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk3      72\n4 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk4      77\n5 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk5      87\n6 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk6      94\n```\n\n\n:::\n:::\n\n\n\n\nWe can see that the  data now has much less columns (5 as opposed to 79 previously). Instead, the number of rows has been increased: each row now corresponds to a week for each song. The weeks were put into a column called 'name' by default, and the values that were in the original week columns went into a column called 'value' by default.\n\nWe can of course change the names of those columns:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Pivot billboard to long format\nbillboard_long <- pivot_longer(billboard, wk1:wk76, names_to = \"week\", values_to = \"position\")\n\n# Reprint billboard\nhead(billboard_long)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 5\n  artist track                   date.entered week  position\n  <chr>  <chr>                   <date>       <chr>    <dbl>\n1 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk1         87\n2 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk2         82\n3 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk3         72\n4 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk4         77\n5 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk5         87\n6 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk6         94\n```\n\n\n:::\n:::\n\n\n\n\nCurrently, the week numbers are in the column called 'week', but are represented as a character string because the characters 'wk' are present in all columns. Although we will learn how to manipulate this in [Regex](regex.qmd), we can prevent this while calling the function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Pivot billboard to long format\nbillboard_long <- pivot_longer(billboard, wk1:wk76, names_to = \"week\", values_to = \"position\", names_prefix = \"wk\")\n\n# Reprint billboard\nhead(billboard_long)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 5\n  artist track                   date.entered week  position\n  <chr>  <chr>                   <date>       <chr>    <dbl>\n1 2 Pac  Baby Don't Cry (Keep... 2000-02-26   1           87\n2 2 Pac  Baby Don't Cry (Keep... 2000-02-26   2           82\n3 2 Pac  Baby Don't Cry (Keep... 2000-02-26   3           72\n4 2 Pac  Baby Don't Cry (Keep... 2000-02-26   4           77\n5 2 Pac  Baby Don't Cry (Keep... 2000-02-26   5           87\n6 2 Pac  Baby Don't Cry (Keep... 2000-02-26   6           94\n```\n\n\n:::\n:::\n\n\n\n\nAlthough we have numbers now, they are still of class 'character'. However, we can specify the type they should be using `names_transform`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Pivot billboard to long format\nbillboard_long <- pivot_longer(billboard, wk1:wk76, names_to = \"week\", values_to = \"position\", names_prefix = \"wk\", names_transform = as.numeric)\n\n# Reprint billboard\nhead(billboard_long)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 5\n  artist track                   date.entered  week position\n  <chr>  <chr>                   <date>       <dbl>    <dbl>\n1 2 Pac  Baby Don't Cry (Keep... 2000-02-26       1       87\n2 2 Pac  Baby Don't Cry (Keep... 2000-02-26       2       82\n3 2 Pac  Baby Don't Cry (Keep... 2000-02-26       3       72\n4 2 Pac  Baby Don't Cry (Keep... 2000-02-26       4       77\n5 2 Pac  Baby Don't Cry (Keep... 2000-02-26       5       87\n6 2 Pac  Baby Don't Cry (Keep... 2000-02-26       6       94\n```\n\n\n:::\n:::\n\n\n\n\nThis kind of control gives us much less head-ache when, for instance, we want to use the data for plotting (for which we will discuss the code in [Plotting](plotting.qmd)):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Load packages\npacman::p_load(\"dplyr\",   # Data wrangling\n               \"ggplot2\"  # Data visualization\n)\n\n# Get only Britney Spears songs\ndat_plot <- filter(billboard_long, artist == \"Spears, Britney\" & !is.na(position))\n\n# Create plot\nggplot(dat_plot, aes(x = week, y = position, colour = track)) +\n    # Geometries\n    geom_line() +\n    # Scaling\n    scale_x_continuous(limits = c(0, 20)) +\n    scale_y_continuous(limits = c(0, 100)) +\n    scale_colour_manual(values = c(\"#d3b866\", \"#e09373\", \"#e586b4\")) + \n    # Aesthetics\n    theme(panel.grid = element_blank(),\n          panel.background = element_rect(colour = \"#002b36\", fill = \"#002b36\"),\n          plot.background = element_rect(colour = \"#002b36\", fill = \"#002b36\"),\n          axis.text = element_text(colour = \"#dee2e6\"),\n          axis.title = element_text(colour = \"#dee2e6\"),\n          axis.line = element_line(colour = \"#dee2e6\"),\n          axis.ticks = element_line(colour = \"#dee2e6\"),\n          legend.text = element_text(colour = \"#dee2e6\"),\n          legend.title = element_blank(),\n          legend.background = element_rect(colour = \"#002b36\", fill = \"#002b36\"),\n          legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](tidyr_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\n\n### Long to wide\nWe can also reshape data from longer to wider format using `pivot_wider()`. We can simply do this by defining which column contains the name and which column contains the values. We can append the final name of the columns using the `names_prefix` argument.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Pivot data to wider formar\nbillboard_wide <- pivot_wider(billboard_long, names_from = week, values_from = position, names_prefix = \"wk\")\n\n# Preview data\nhead(billboard_wide)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 79\n  artist      track date.entered   wk1   wk2   wk3   wk4   wk5   wk6   wk7   wk8\n  <chr>       <chr> <date>       <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1 2 Pac       Baby… 2000-02-26      87    82    72    77    87    94    99    NA\n2 2Ge+her     The … 2000-09-02      91    87    92    NA    NA    NA    NA    NA\n3 3 Doors Do… Kryp… 2000-04-08      81    70    68    67    66    57    54    53\n4 3 Doors Do… Loser 2000-10-21      76    76    72    69    67    65    55    59\n5 504 Boyz    Wobb… 2000-04-15      57    34    25    17    17    31    36    49\n6 98^0        Give… 2000-08-19      51    39    34    26    26    19     2     2\n# ℹ 68 more variables: wk9 <dbl>, wk10 <dbl>, wk11 <dbl>, wk12 <dbl>,\n#   wk13 <dbl>, wk14 <dbl>, wk15 <dbl>, wk16 <dbl>, wk17 <dbl>, wk18 <dbl>,\n#   wk19 <dbl>, wk20 <dbl>, wk21 <dbl>, wk22 <dbl>, wk23 <dbl>, wk24 <dbl>,\n#   wk25 <dbl>, wk26 <dbl>, wk27 <dbl>, wk28 <dbl>, wk29 <dbl>, wk30 <dbl>,\n#   wk31 <dbl>, wk32 <dbl>, wk33 <dbl>, wk34 <dbl>, wk35 <dbl>, wk36 <dbl>,\n#   wk37 <dbl>, wk38 <dbl>, wk39 <dbl>, wk40 <dbl>, wk41 <dbl>, wk42 <dbl>,\n#   wk43 <dbl>, wk44 <dbl>, wk45 <dbl>, wk46 <dbl>, wk47 <dbl>, wk48 <dbl>, …\n```\n\n\n:::\n:::\n\n\n\n\nThis returns the data to its original state (note that missings cannot be compared):\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Compare all individual values in the data frames\ntable(billboard == billboard_wide, useNA = \"always\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n TRUE  <NA> \n 6258 18785 \n```\n\n\n:::\n:::\n\n\n\n\n## Filling in `NA`'s\n### Single value for a whole column\nSometimes, we have missing values in columns (i.e. `NA`'s), that we want to change. This can be due to some assumptions we have made (e.g. absence of a diagnostic code in a health record means absence of the corresponding disease), because we want to name our missings something different than `NA`, or because we otherwise know what these values should be (e.g. an artificial indicator).\n\nTo do this, we can use the function `replace_na()`, which allows us to specify what missing values should be for each individual column specified. As an example, we will change missing values in the `billboard` data to -1 for the weeks 20 and 21, to indicate the song was no longer in the top 100 in the week specified by that column.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Change NAs in weeks 66 and 67\nbillboard_replaced <- replace_na(billboard, list(wk20 = -1, wk21 = -1))\n\n# Show that these values now exist where missing data first existed for week 20\ntable(billboard[[\"wk20\"]], useNA = \"always\"); table(billboard_replaced[[\"wk20\"]], useNA = \"always\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n   2    3    4    5    6    7    9   10   11   12   14   15   16   18   19   20 \n   2    2    3    2    1    2    1    4    1    2    4    4    1    1    1    3 \n  21   22   23   25   26   28   30   33   34   35   39   40   42   43   45   46 \n   1    2    3    4    3    1    3    1    2    1    1    1    2    1    1    1 \n  48   49   50   51   53   54   56   58   59   61   62   66   67   68   69   70 \n   1    1    2    1    1    2    1    2    3    1    3    2    1    2    1    3 \n  71   72   74   77   78   79   82   83   84   85   86   87   88   89   90   91 \n   1    1    1    2    2    2    1    1    1    1    4    5    2    6    4    3 \n  92   93   94   95   96   97   98   99  100 <NA> \n   2    1    2    3    1    2    1    3    5  171 \n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n  -1    2    3    4    5    6    7    9   10   11   12   14   15   16   18   19 \n 171    2    2    3    2    1    2    1    4    1    2    4    4    1    1    1 \n  20   21   22   23   25   26   28   30   33   34   35   39   40   42   43   45 \n   3    1    2    3    4    3    1    3    1    2    1    1    1    2    1    1 \n  46   48   49   50   51   53   54   56   58   59   61   62   66   67   68   69 \n   1    1    1    2    1    1    2    1    2    3    1    3    2    1    2    1 \n  70   71   72   74   77   78   79   82   83   84   85   86   87   88   89   90 \n   3    1    1    1    2    2    2    1    1    1    1    4    5    2    6    4 \n  91   92   93   94   95   96   97   98   99  100 <NA> \n   3    2    1    2    3    1    2    1    3    5    0 \n```\n\n\n:::\n:::\n\n\n\n\n### Based on other values in column\nIn some cases, we want to copy the value of a certain column to other, missing rows in that column. As an example, this could be the case of biological sex at birth is recorded only in a first study visit, even though biological sex at birth remains constant over time (because birth only occurs once). For this, we can use the `fill()` function.\n\nThe `fill()` function allows us to fill the value in a column. We can specify one of four directions for how the filling occurrs. Note this example data:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Create example data for fill()\ndat_fill <- tibble(id = c(1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4),\n                   visit = rep(1:3, 4),\n                   bio_sex_birth = c(\"male\", NA, NA, NA, \"female\", NA, \n                                     NA, NA, NA, \"male\", NA, NA))\n\n# Show data\ndat_fill\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 3\n      id visit bio_sex_birth\n   <dbl> <int> <chr>        \n 1     1     1 male         \n 2     1     2 <NA>         \n 3     1     3 <NA>         \n 4     2     1 <NA>         \n 5     2     2 female       \n 6     2     3 <NA>         \n 7     3     1 <NA>         \n 8     3     2 <NA>         \n 9     3     3 <NA>         \n10     4     1 male         \n11     4     2 <NA>         \n12     4     3 <NA>         \n```\n\n\n:::\n:::\n\n\n\n\nWe can see that for three individuals, we know their biological sex at birth, for one individual, this information was recored at visit 2 (ID 2), and for one individual (ID 3), this information is missing. To fill in these missing values, we can use `fill()`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Fill missing values downwards\nfill(dat_fill, bio_sex_birth, .direction = \"down\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 3\n      id visit bio_sex_birth\n   <dbl> <int> <chr>        \n 1     1     1 male         \n 2     1     2 male         \n 3     1     3 male         \n 4     2     1 male         \n 5     2     2 female       \n 6     2     3 female       \n 7     3     1 female       \n 8     3     2 female       \n 9     3     3 female       \n10     4     1 male         \n11     4     2 male         \n12     4     3 male         \n```\n\n\n:::\n:::\n\n\n\n\nWhen the fill direction is down, we can see that each value is only filled in downwards. The downwards direction poses a problem for individual 2 that now switches biological sex at birth, which should not be possible.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Fill missing values upwards\nfill(dat_fill, bio_sex_birth, .direction = \"up\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 3\n      id visit bio_sex_birth\n   <dbl> <int> <chr>        \n 1     1     1 male         \n 2     1     2 female       \n 3     1     3 female       \n 4     2     1 female       \n 5     2     2 female       \n 6     2     3 male         \n 7     3     1 male         \n 8     3     2 male         \n 9     3     3 male         \n10     4     1 male         \n11     4     2 <NA>         \n12     4     3 <NA>         \n```\n\n\n:::\n:::\n\n\n\n\nWhen the fill direction is up, we just fill upwards, which means that individual 4 does not get their missing values filled in.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Fill missing values downwards then upwards\nfill(dat_fill, bio_sex_birth, .direction = \"downup\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 3\n      id visit bio_sex_birth\n   <dbl> <int> <chr>        \n 1     1     1 male         \n 2     1     2 male         \n 3     1     3 male         \n 4     2     1 male         \n 5     2     2 female       \n 6     2     3 female       \n 7     3     1 female       \n 8     3     2 female       \n 9     3     3 female       \n10     4     1 male         \n11     4     2 male         \n12     4     3 male         \n```\n\n\n:::\n:::\n\n\n\n\nThe direction downup simply means that first we fill downwards and then upwards, meaning that when the filling upwards occurs, there are already some `NA`'s filled in by the downward filling.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Fill missing values upwards then downwards\nfill(dat_fill, bio_sex_birth, .direction = \"updown\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 3\n      id visit bio_sex_birth\n   <dbl> <int> <chr>        \n 1     1     1 male         \n 2     1     2 female       \n 3     1     3 female       \n 4     2     1 female       \n 5     2     2 female       \n 6     2     3 male         \n 7     3     1 male         \n 8     3     2 male         \n 9     3     3 male         \n10     4     1 male         \n11     4     2 male         \n12     4     3 male         \n```\n\n\n:::\n:::\n\n\n\n\nThe updown direction is alike the downup direction, but just the other way around.\n\nImportantly however, all these directions fill also the missing values for individual 3, even though we do not know their actual value. This is why it is always important to evaluate whether you need to fill within a grouping structure. If we apply this here, we can see that both updown and downup give us the correct results:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Fill missing values\ndat_fill %>%\n    # Arrange for grouping\n    arrange(id) %>%\n    # Create groups out of individuals\n    group_by(id) %>%\n    # Fill values downwards then upwards\n    fill(bio_sex_birth, .direction = \"downup\") %>%\n    # Remove grouping structure\n    ungroup()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 3\n      id visit bio_sex_birth\n   <dbl> <int> <chr>        \n 1     1     1 male         \n 2     1     2 male         \n 3     1     3 male         \n 4     2     1 female       \n 5     2     2 female       \n 6     2     3 female       \n 7     3     1 <NA>         \n 8     3     2 <NA>         \n 9     3     3 <NA>         \n10     4     1 male         \n11     4     2 male         \n12     4     3 male         \n```\n\n\n:::\n:::\n\n\n\n\nThere are also cases where we are only interested in filling values in a single direction only, such as when a measurement should only be available from a certain point onwards.\n\n## Exercises\nFor these exercises, we will use the `storms` dataset available in `{dplyr}`.\n\n### 1. Continue storm category\nImagine that we want to say that a storm keeps their hurricane category, even after it ceases to be a hurricane. Tidy the data to portray this.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Fill the category downwards in grouped data\nstorms %>%\n    # Arrange for grouping\n    arrange(name) %>%\n    # Group per storm\n    group_by(name) %>%\n    # Fill category downwards only\n    fill(category, .direction = \"down\") %>%\n    # Remove grouping structure\n    ungroup() %>%\n    ## Only to show what answer should look like\n    # Show storm Gladys as an example\n    filter(name == \"Gladys\") %>%\n    # Print all rows\n    print(n = 46)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 46 × 13\n   name    year month   day  hour   lat  long status     category  wind pressure\n   <chr>  <dbl> <dbl> <int> <dbl> <dbl> <dbl> <fct>         <dbl> <int>    <int>\n 1 Gladys  1975     9    22    18  10.3 -34.8 tropical …       NA    25     1012\n 2 Gladys  1975     9    23     0  10.6 -35.8 tropical …       NA    25     1012\n 3 Gladys  1975     9    23     6  11   -36.7 tropical …       NA    25     1012\n 4 Gladys  1975     9    23    12  11.4 -37.4 tropical …       NA    25     1012\n 5 Gladys  1975     9    23    18  11.7 -38.2 tropical …       NA    30     1010\n 6 Gladys  1975     9    24     0  12.1 -38.8 tropical …       NA    30     1010\n 7 Gladys  1975     9    24     6  12.4 -39.6 tropical …       NA    30     1010\n 8 Gladys  1975     9    24    12  12.9 -40   tropical …       NA    30     1010\n 9 Gladys  1975     9    24    18  13.5 -40.4 tropical …       NA    35     1005\n10 Gladys  1975     9    25     0  14.2 -41   tropical …       NA    40     1005\n11 Gladys  1975     9    25     6  14.8 -42   tropical …       NA    50     1000\n12 Gladys  1975     9    25    12  15.4 -43   tropical …       NA    60     1000\n13 Gladys  1975     9    25    18  15.8 -44   hurricane         1    65      990\n14 Gladys  1975     9    26     0  16.2 -45   hurricane         1    65      990\n15 Gladys  1975     9    26     6  16.4 -46.1 hurricane         1    65      990\n16 Gladys  1975     9    26    12  16.6 -47.7 hurricane         1    65      990\n17 Gladys  1975     9    26    18  16.8 -49.3 hurricane         1    65      990\n18 Gladys  1975     9    27     0  17.1 -50.7 hurricane         1    65      990\n19 Gladys  1975     9    27     6  17.6 -52.2 hurricane         1    65      990\n20 Gladys  1975     9    27    12  18.2 -53.7 hurricane         1    65      990\n21 Gladys  1975     9    27    18  18.8 -55.1 hurricane         1    65      990\n22 Gladys  1975     9    28     0  19.4 -56.4 hurricane         1    65      992\n23 Gladys  1975     9    28     6  19.6 -57.4 hurricane         1    65      992\n24 Gladys  1975     9    28    12  19.8 -58.2 hurricane         1    65     1000\n25 Gladys  1975     9    28    18  20.3 -59.3 hurricane         1    65      998\n26 Gladys  1975     9    29     0  21.2 -60.3 hurricane         1    65      995\n27 Gladys  1975     9    29     6  22.1 -61.4 hurricane         1    70      990\n28 Gladys  1975     9    29    12  23   -62.6 hurricane         1    70      990\n29 Gladys  1975     9    29    18  23.6 -63.9 hurricane         1    75      985\n30 Gladys  1975     9    30     0  24.1 -65.2 hurricane         1    80      975\n31 Gladys  1975     9    30     6  24.6 -66.5 hurricane         1    80      975\n32 Gladys  1975     9    30    12  25.1 -67.9 hurricane         1    80      975\n33 Gladys  1975     9    30    18  25.6 -69.3 hurricane         1    80      975\n34 Gladys  1975    10     1     0  26.1 -70.6 hurricane         1    80      975\n35 Gladys  1975    10     1     6  26.8 -71.7 hurricane         1    80      975\n36 Gladys  1975    10     1    12  27.9 -72.4 hurricane         1    80      975\n37 Gladys  1975    10     1    18  29.4 -73   hurricane         2    90      969\n38 Gladys  1975    10     2     0  31   -73   hurricane         3   100      954\n39 Gladys  1975    10     2     6  32.9 -72.1 hurricane         3   110      942\n40 Gladys  1975    10     2    12  35.3 -69.8 hurricane         4   120      939\n41 Gladys  1975    10     2    18  37.8 -67   hurricane         4   120      939\n42 Gladys  1975    10     3     0  40.8 -62.6 hurricane         3   110      950\n43 Gladys  1975    10     3     6  43.7 -57   hurricane         2    85      960\n44 Gladys  1975    10     3    12  46.6 -50.6 hurricane         2    85      960\n45 Gladys  1975    10     3    18  50.5 -45.5 extratrop…        2    75      975\n46 Gladys  1975    10     4     0  55   -40   extratrop…        2    65      980\n# ℹ 2 more variables: tropicalstorm_force_diameter <int>,\n#   hurricane_force_diameter <int>\n```\n\n\n:::\n:::\n\n\n\n\n### 2. Indicate non-hurricanes\nAs an alternative, set category to -1 if the storm was not a hurricane (and therefore the category is `NA`).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set NA's to -1\nstorms_replaced <- replace_na(storms, list(category = -1))\n\n# See categories in storms_replaced\ntable(storms_replaced[[\"category\"]], useNA = \"always\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n   -1     1     2     3     4     5  <NA> \n14734  2548   993   593   553   116     0 \n```\n\n\n:::\n:::\n\n\n\n\n## Next topic\nNow that we have seen how we tidy our data, the last thing left for us to discuss in the tidyverse is how to combine all these functions into efficient pipelines using `{magrittr}` and the pipe (`%>%`).\n\n**Next:** [Magrittr](magrittr.qmd)",
    "supporting": [
      "tidyr_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}