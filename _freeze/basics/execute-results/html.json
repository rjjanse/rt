{
  "hash": "e677c78360d0a7b287c415e6f0b77dc7",
  "result": {
    "markdown": "---\ntitle: \"Basics\"\n---\n\n\n## Annotation\nLet's get started in R. Before we write any code, we should discuss the importance of annotation. When you are writing code it might seem clear to you what each line does, but if someone else reads your code or you look back at your code after a while, it might not seem so clear anymore. To allow others and your future-self to efficiently check, read, and re-use your code, it is important to **extensively** annotate your code. Let's see some unannotated code (you don't have to understand now what the code means):\n\n```r\niris %>%\n    filter(Species == \"setosa\") %>%\n    extract2(\"Sepal.Length\") %>%\n    is_greater_than(5) %>%\n    table() %>%\n    prop.table() %>%\n    extract2(TRUE) %>%\n    `*`(100) %>%\n    paste0(., \"%\")\n```\n\nIn this section of code, there is a lot that happens (although some R users might still get the gist of the code). Moreover, a single section of code might quickly get much longer and more complicated than the above example. Luckily, the code can added to with annotation. In R, you can annotate with '#'. Any text written after the '#' on the same line will not be run by R and can therefore be used to annotate code. So let's see how we can increase this code's clarity with annotation:\n\n```r\n# Calculate proportion of setosa observations with sepal length above 5\niris %>%\n    # Keep only setosa species\n    filter(Species == \"setosa\") %>%\n    # Keep only the sepal length values\n    extract2(\"Sepal.Length\") %>%\n    # Determine whether each value is greater than 5 or not\n    is_greater_than(5) %>%\n    # Count lengths above and below 5\n    table() %>%\n    # Turn counts into proportions\n    prop.table() %>%\n    # Keep only proportion for lengths above 5\n    extract2(TRUE) %>%\n    # Multiply by 100\n    `*`(100) %>%\n    # Add percentage sign\n    paste0(., \"%\")\n```\n\nIt is true that annotation increases the length of a script, but it is important to note that the quality of a script is not affected by its length, but it is by its clarity.\n\n::: {.callout-tip appearance=\"simple\"}\nYou can use annotation for more than just explaining what your code does. You can add information on the general purpose of a script, its author, its creation date. You can add information on why you made a certain decision or add a URL to where you found the solution to a coding problem. It is easy to annotate too little, but difficult to annotate too much.\n:::\n\n## Basic mathematic operators and running code\nNow let's (finally) see some real code! Let's start with some basic operators:\n\n```r\n1 + 1   # Addition\n3 - 1   # Substraction\n2 * 3   # Multiplication\n8 / 2   # Division\n8 %% 2  # Modulo\n```\n\nR follows the [conventional order of mathematic operation](https://en.wikipedia.org/wiki/Order_of_operations#Programming_languages).\n\nHowever, these operators are useless if we do not actually run the code. To run a section of code, put your cursor in the code section (can be anywhere) and press ctrl + enter to run the code. If you want to run a specific part of the code, instead of a whole section, you can select the part you want to run and then use ctrl + enter again, to run only the selected part. \n\nThe results of the selected code can be found in the console. If the code takes some time to run, you can see it is done when a new line of the console starts with > (@fig-ready).\n\n::: {.callout-important appearance=\"simple\"}\nIf you select a specific part of code to run, make sure to be inclusive! For instance, if you forget to select an enclosing paranthesis, the selected code will be put in the console, but it will not be run. You can see that this happened if a new line in the console starts with + (@fig-waiting). To cancel a waiting command, you can press esc.\n:::\n\nIf we run the example code for the basic mathematic operators, we will get the following results:\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n\nBefore each result, you can see `[1]`. This indicates that that specific line of code starts with the n^th^ result. When a single code starts printing multiple results, this can help identify what n a certain result is.\n\n::: {#fig-console layout-ncol=2}\n![Ready](images/console_ready.png){#fig-ready fig-alt=\"ready console\" width=45%}\n\n![Waiting for input to finish](images/console_waiting.png){#fig-waiting fig-alt=\"waiting console\" width=45%}\n\nConsole states\n:::\n\n## Functions\nNow that we know the basic mathematic operators, we could calculate the standard deviation. For example, for the numbers 3, 8, 3, 7 and 1, we could do the following:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Calculate the mean\n(3 + 8 + 3 + 7 + 1) / 5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4.4\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Use the calculated mean to calculate the standard deviation\n(((3 - 4.4) ^ 2 + (8 - 4.4) ^ 2 + (3 - 4.4) ^ 2 + (7 - 4.4) ^ 2 + (1 - 4.4) ^ 2) / (5 - 1)) ^ 0.5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.966479\n```\n:::\n:::\n\n\n::: {.column-margin}\nA sample's standard deviation $s$ is obtained by calculating:\n\n$$\\sqrt\\frac{\\sum{(x-\\overline{x})^2}}{n-1}$$\n:::\n\nHowever, with only 5 numbers, this is already a lot of effort. This is where functions come in: R has many built-in keywords that allow you to quickly perform operations and/or calculations on the data, which we call functions. A function has a generic name and is followed by opening and closing brackets. Between the brackets, we can supply so-called arguments (i.e., data and/or specifications). For example, if we wanted to calculate the standard deviation, instead of typing out all the numbers, we could just type the following:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Calculate standard deviation\nsd(c(3, 8, 3, 7, 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.966479\n```\n:::\n:::\n\n\n:::{.callout-note appearance=\"simple\"}\nThe `c()` function we used when calculating the standard deviation will be elaborated upon in the next section, so don't worry about it for now!\n::: \n\n\n\n\n<!-- To do:\n•\tFunctions\n•\tBasic functions\no\tSum, mean, median, summary, quintiles, min, max, table\n•\tStoring values in objects\no\tSingle value\n\tWhat operator to use: <- or =\no\tVector (& what is a vector)\no\tList\no\tMatrices\n\tTransforming to matrices\no\tDataframes\n\tDimensions: nrow, ncol\n\tSetting column names\n\tTransforming to data frames\n\tTransforming matrices to data frames\n•\tFinding source code of a function\n•\tMethods() of functions\n•\tGlobal environment\no\tGet & assign\nErrors -->\n\n",
    "supporting": [
      "basics_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}